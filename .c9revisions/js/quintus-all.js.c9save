{"ts":1366899483407,"silentsave":true,"restoring":false,"patch":[[]],"length":0}
{"contributors":[],"silentsave":false,"ts":1366899555126,"patch":[[{"diffs":[[1,"/*! Quintus - v0.1.1 - 2013-02-17\n* Copyright (c) 2013 Pascal Rettig; Licensed MIT, GPLv2 */\n\n//     Quintus Game Engine\n//     (c) 2012 Pascal Rettig, Cykod LLC\n//     Quintus may be freely distributed under the MIT license or GPLv2 License.\n//     For all details and documentation:\n//     http://html5quintus.com\n//\n// Quintus HTML5 Game Engine \n// =========================\n//\n// The code in `quintus.js` defines the base `Quintus()` method\n// which create an instance of the engine. The basic engine doesn't\n// do a whole lot - it provides an architecture for extension, a\n// game loop, and a method for creating or binding to an exsiting\n// canvas context. The engine has dependencies on Underscore.js and jQuery,\n// although the jQuery dependency will be removed in the future.\n//\n// Most of the game-specific functionality is in the \n// various other modules:\n//\n// * `quintus_input.js` - `Input` module, which allows for user input via keyboard and touchscreen\n// * `quintus_sprites.js` - `Sprites` module, which defines a basic `Q.Sprite` class along with spritesheet support in `Q.SpriteSheet`.\n// * `quintus_scenes.js` - `Scenes` module. It defines the `Q.Scene` class, which allows creation of reusable scenes, and the `Q.Stage` class, which handles managing a number of sprites at once.\n// * `quintus_anim.js` - `Anim` module, which adds in support for animations on sprites along with a `viewport` component to follow the player around and a `Q.Repeater` class that can create a repeating, scrolling background.\n\n\n// Engine Bootstrapping\n// ====================\n\n// Top-level Quintus engine factory wrapper, \n// creates new instances of the engine by calling:\n//\n//      var Q = Quintus({  ...  });\n//\n// Any initial setup methods also all return the `Q` object, allowing any initial \n// setup calls to be chained together.\n//\n//      var Q = Quintus()\n//              .include(\"Input, Sprites, Scenes\")\n//              .setup('quintus', { maximize: true })\n//              .controls();\n//                       \n// `Q` is used internally as the object name, and is used in most of the examples, \n// but multiple instances of the engine on the same page can have different names.\n//\n//     var Game1 = Quintus(), Game2 = Quintus();\n//\nvar Quintus = function Quintus(opts) {\n\n  // A la jQuery - the returned `Q` object is actually\n  // a method that calls `Q.select`. `Q.select` doesn't do anything\n  // initially, but can be overridden by a module to allow\n  // selection of game objects. The `Scenes` module adds in \n  // the select method which selects from the default stage.\n  //\n  //     var Q = Quintus().include(\"Sprites, Scenes\");\n  //     ... Game Code ...\n  //     // Set the angry property on all Enemy1 class objects to true\n  //     Q(\"Enemy1\").p({ angry: true });\n  //     \n  var Q = function(selector,scope,options) {   \n    return Q.select(selector,scope,options);\n  };\n\n  Q.select = function() { /* No-op */ };\n\n  // Syntax for including other modules into quintus, can accept a comma-separated\n  // list of strings, an array of strings, or an array of actual objects. Example:\n  //\n  //     Q.include(\"Input, Sprites, Scenes\")\n  //\n  Q.include = function(mod) {\n    Q._each(Q._normalizeArg(mod),function(name) {\n      var m = Quintus[name] || name;\n      if(!Q._isFunction(m)) { throw \"Invalid Module:\" + name; }\n      m(Q);\n    });\n    return Q;\n  };\n\n  // Utility Methods\n  // ===============\n  //\n  // Most of these utility methods are a subset of Underscore.js,\n  // Most are pulled directly from underscore and some are\n  // occasionally optimized for speed and memory usage in lieu of flexibility.\n  // Underscore.js is (c) 2009-2012 Jeremy Ashkenas, DocumentCloud Inc.\n  // Underscore is freely distributable under the MIT license.\n  // http://underscorejs.org\n\n  // An internal utility method (utility methods are prefixed with underscores)\n  // It's used to take a string of comma separated names and turn it into an `Array`\n  // of names. If an array of names is passed in, it's left as is. Example usage:\n  //\n  //     Q._normalizeArg(\"Sprites, Scenes, Physics   \");\n  //     // returns [ \"Sprites\", \"Scenes\", \"Physics\" ]\n  //\n  // Used by `Q.include` and `Q.Sprite.add` to add modules and components, respectively.\n  Q._normalizeArg = function(arg) {\n    if(Q._isString(arg)) {\n      arg = arg.replace(/\\s+/g,'').split(\",\");\n    }\n    if(!Q._isArray(arg)) {\n      arg = [ arg ];\n    }\n    return arg;\n  };\n\n\n  // Extends a destination object\n  // with a source object\n  Q._extend = function(dest,source) {\n    if(!source) { return dest; }\n    for (var prop in source) {\n      dest[prop] = source[prop];\n    }\n    return dest;\n  };\n\n  // Return a shallow copy of an object. Sub-objects (and sub-arrays) are not cloned.\n  Q._clone = function(obj) {\n    return Q._extend({},obj);\n  };\n\n  // Method that adds default properties onto\n  // an object only if the key is undefined\n  Q._defaults = function(dest,source) {\n    if(!source) { return dest; }\n    for (var prop in source) {\n      if(dest[prop] === void 0) {\n        dest[prop] = source[prop];\n      }\n    }\n    return dest;\n  };\n\n  // Shortcut for hasOwnProperty\n  Q._has = function(obj, key) {\n    return Object.prototype.hasOwnProperty.call(obj, key);\n  };\n\n  // Check if something is a string\n  // NOTE: this fails for non-primitives\n  Q._isString = function(obj) {\n    return typeof obj === \"string\";\n  };\n\n  Q._isNumber = function(obj) {\n    return Object.prototype.toString.call(obj) === '[object Number]';\n  };\n\n  // Check if something is a function\n  Q._isFunction = function(obj) {\n    return Object.prototype.toString.call(obj) === '[object Function]';\n  };\n\n  // Check if something is a function\n  Q._isObject = function(obj) {\n    return Object.prototype.toString.call(obj) === '[object Object]';\n  };\n\n  // Check if something is a function\n  Q._isArray = function(obj) {\n    return Object.prototype.toString.call(obj) === '[object Array]';\n  };\n\n  // Check if something is undefined\n  Q._isUndefined = function(obj) {\n    return obj === void 0;\n  };\n\n  // Removes a property from an object and returns it\n  Q._popProperty = function(obj,property) {\n    var val = obj[property];\n    delete obj[property];\n    return val;\n  };\n\n  // Basic iteration method. This can often be a performance\n  // handicap when the callback iterator is created inline,\n  // as this leads to lots of functions that need to be GC'd.\n  // Better is to define the iterator as a private method so\n  // it is only created once.\n  Q._each = function(obj,iterator,context) {\n    if (obj == null) { return; }\n    if (obj.forEach) {\n      obj.forEach(iterator,context);\n    } else if (obj.length === +obj.length) {\n      for (var i = 0, l = obj.length; i < l; i++) {\n        iterator.call(context, obj[i], i, obj);\n      }\n    } else {\n      for (var key in obj) {\n        iterator.call(context, obj[key], key, obj);\n      }\n    }\n  };\n\n  // Invoke the named property on each element of the array\n  Q._invoke= function(arr,property,arg1,arg2) {\n    if (arr == null) { return; }\n    for (var i = 0, l = arr.length; i < l; i++) {\n      arr[i][property](arg1,arg2);\n    }\n  };\n\n\n\n  // Basic detection method, returns the first instance where the\n  // iterator returns truthy. \n  Q._detect = function(obj,iterator,context,arg1,arg2) {\n    var result;\n    if (obj == null) { return; }\n    if (obj.length === +obj.length) {\n      for (var i = 0, l = obj.length; i < l; i++) {\n        result = iterator.call(context, obj[i], i, arg1,arg2);\n        if(result) { return result; }\n      }\n      return false;\n    } else {\n      for (var key in obj) {\n        result = iterator.call(context, obj[key], key, arg1,arg2);\n        if(result) { return result; }\n      }\n      return false;\n    }\n  };\n\n  // Returns a new Array with entries set to the return value of the iterator.\n  Q._map = function(obj, iterator, context) {\n    var results = [];\n    if (obj == null) { return results; }\n    if (obj.map) { return obj.map(iterator, context); }\n    Q._each(obj, function(value, index, list) {\n      results[results.length] = iterator.call(context, value, index, list);\n    });\n    if (obj.length === +obj.length) { results.length = obj.length; }\n    return results;\n  };\n\n  // Returns a sorted copy of unique array elements with null remove\n  Q._uniq = function(arr) {\n    arr = arr.slice().sort();\n\n    var output = [];\n\n    var last = null;\n    for(var i=0;i<arr.length;i++) {\n      if(arr[i] !== void 0 && last !== arr[i]) {\n        output.push(arr[i]);\n      }\n      last = arr[i];\n    }\n    return output;\n  };\n\n  // returns a new array with the same entries as the source but in a random order.\n  Q._shuffle = function(obj) {\n    var shuffled = [], rand;\n    Q._each(obj, function(value, index, list) {\n      rand = Math.floor(Math.random() * (index + 1));\n      shuffled[index] = shuffled[rand];\n      shuffled[rand] = value;\n    });\n    return shuffled;\n  };\n\n  // Return an object's keys\n  Q._keys = Object.keys || function(obj) {\n    if(Q._isObject(obj)) { throw new TypeError('Invalid object'); }\n    var keys = [];\n    for (var key in obj) { if (Q._has(obj, key)) { keys[keys.length] = key; } } \n    return keys;\n  };\n\n  Q._range = function(start,stop,step) {\n    step = arguments[2] || 1;\n\n    var len = Math.max(Math.ceil((stop - start) / step), 0);\n    var idx = 0;\n    var range = new Array(len);\n\n    while(idx < len) {\n      range[idx++] = start;\n      start += step;\n    }\n\n    return range;\n\n  };\n\n  var idIndex = 0;\n  // Return a unique identifier\n  Q._uniqueId = function() {\n    return idIndex++;\n  };\n\n\n\n  // Options\n  // ========\n  \n  // Default engine options defining the paths \n  // where images, audio and other data files should be found\n  // relative to the base HTML file. As well as a couple of other\n  // options.\n  //\n  // These can be overriden by passing in options to the `Quintus()` \n  // factory method, for example:\n  //\n  //     // Override the imagePath to default to /assets/images/\n  //     var Q = Quintus({ imagePath: \"/assets/images/\" });\n  //\n  // If you follow the default convention from the examples, however,\n  // you should be able to call `Quintus()` without any options.\n  Q.options = {\n    imagePath: \"images/\",\n    audioPath: \"audio/\",\n    dataPath:  \"data/\",\n    audioSupported: [ 'mp3','ogg' ],\n    sound: true,\n    frameTimeLimit: 100\n  };\n  if(opts) { Q._extend(Q.options,opts); }\n\n\n  // Game Loop support\n  // =================\n\n\n\n  // By default the engine doesn't start a game loop until you actually tell it to.\n  // Usually the loop is started the first time you call `Q.stageScene`, but if you \n  // aren't using the `Scenes` module you can explicitly start the game loop yourself\n  // and control **exactly** what the engine does each cycle. For example:\n  //\n  //     var Q = Quintus().setup();\n  //\n  //     var ball = new Q.Sprite({ .. });\n  //\n  //     Q.gameLoop(function(dt) {\n  //       Q.clear(); \n  //       ball.step(dt);\n  //       ball.draw(Q.ctx);\n  //     });\n  //\n  // The callback will be called with fraction of a second that has elapsed since \n  // the last call to the loop method.\n  Q.gameLoop = function(callback) {\n    Q.lastGameLoopFrame = new Date().getTime();\n\n    // Short circuit the loop check in case multiple scenes\n    // are staged immediately\n    Q.loop = true; \n\n    // Keep track of the frame we are on (so that animations can be synced\n    // to the next frame)\n    Q._loopFrame = 0;\n\n    // Wrap the callback to save it and standardize the passed\n    // in time. \n    Q.gameLoopCallbackWrapper = function() {\n      var now = new Date().getTime();\n      Q._loopFrame++;\n      Q.loop = window.requestAnimationFrame(Q.gameLoopCallbackWrapper);\n      var dt = now - Q.lastGameLoopFrame;\n      /* Prevent fast-forwarding by limiting the length of a single frame. */\n      if(dt > Q.options.frameTimeLimit) { dt = Q.options.frameTimeLimit; }\n      callback.apply(Q,[dt / 1000]);  \n      Q.lastGameLoopFrame = now;\n    };\n\n    window.requestAnimationFrame(Q.gameLoopCallbackWrapper);\n    return Q;\n  };\n\n  // Pause the entire game by canceling the requestAnimationFrame call. If you use setTimeout or\n  // setInterval in your game, those will, of course, keep on rolling...\n  Q.pauseGame = function() {\n    if(Q.loop) {\n      window.cancelAnimationFrame(Q.loop); \n    }\n    Q.loop = null;\n  };\n\n  // Unpause the game by restarting the requestAnimationFrame-based loop.\n  Q.unpauseGame = function() {\n    if(!Q.loop) {\n      Q.lastGameLoopFrame = new Date().getTime();\n      Q.loop = window.requestAnimationFrame(Q.gameLoopCallbackWrapper);\n    }\n  };\n\n\n  // The base Class object\n  // ===============\n  //\n  // Quintus uses the Simple JavaScript inheritance Class object, created by\n  // John Resig and described on his blog: \n  //\n  // [http://ejohn.org/blog/simple-javascript-inheritance/](http://ejohn.org/blog/simple-javascript-inheritance/)\n  //\n  // The class is used wholesale, with the only differences being that instead\n  // of appearing in a top-level namespace, the `Class` object is available as \n  // `Q.Class` and a second argument on the `extend` method allows for adding\n  // class level methods and the class name is passed in a parameter for introspection\n  // purposes.\n  //\n  // Classes can be created by calling `Q.Class.extend(name,{ .. })`, although most of the time\n  // you'll want to use one of the derivitive classes, `Q.Evented` or `Q.GameObject` which\n  // have a little bit of functionality built-in. `Q.Evented` adds event binding and \n  // triggering support and `Q.GameObject` adds support for components and a destroy method.\n  //\n  // The main things Q.Class get you are easy inheritance, a constructor method called `init()`,\n  // dynamic addition of a this._super method when a method is overloaded (be careful with \n  // this as it adds some overhead to method calls.) Calls to `instanceof` also all \n  // work as you'd hope.\n  //\n  // By convention, classes should be added onto to the `Q` object and capitalized, so if \n  // you wanted to create a new class for your game, you'd write:\n  //\n  //     Q.Class.extend(\"MyClass\",{ ... });\n  //\n  // Examples:\n  //\n  //     Q.Class.extend(\"Bird\",{ \n  //       init: function(name) { this.name = name; },\n  //       speak: function() { console.log(this.name); },\n  //       fly: function()   { console.log(\"Flying\"); }\n  //     });\n  //\n  //     Q.Bird.extend(\"Penguin\",{\n  //       speak: function() { console.log(this.name + \" the penguin\"); },\n  //       fly: function()   { console.log(\"Can't fly, sorry...\"); }\n  //     });\n  //\n  //     var randomBird = new Q.Bird(\"Frank\"),\n  //         pengy      = new Q.Penguin(\"Pengy\");\n  //\n  //     randomBird.fly(); // Logs \"Flying\"\n  //     pengy.fly();      // Logs \"Can't fly,sorry...\"\n  //\n  //     randomBird.speak(); // Logs \"Frank\"\n  //     pengy.speak();      // Logs \"Pengy the penguin\"\n  //\n  //     console.log(randomBird instanceof Q.Bird);    // true \n  //     console.log(randomBird instanceof Q.Penguin); // false\n  //     console.log(pengy instanceof Q.Bird);         // true \n  //     console.log(pengy instanceof Q.Penguin);      // true \n\n\n  /* Simple JavaScript Inheritance\n   * By John Resig http://ejohn.org/\n   * MIT Licensed.\n   *\n   * Inspired by base2 and Prototype\n   */\n  (function(){\n    var initializing = false, \n        fnTest = /xyz/.test(function(){ var xyz;}) ? /\\b_super\\b/ : /.*/;\n    /* The base Class implementation (does nothing) */\n    Q.Class = function(){};\n\n    // See if a object is a specific class\n    Q.Class.prototype.isA = function(className) {\n      return this.className === className;\n    };\n    \n    /* Create a new Class that inherits from this class */\n    Q.Class.extend = function(className, prop, classMethods) {\n      /* No name, don't add onto Q */\n      if(!Q._isString(className)) {\n        classMethods = prop;\n        prop = className;\n        className = null;\n      }\n      var _super = this.prototype,\n          ThisClass = this;\n      \n      /* Instantiate a base class (but only create the instance, */\n      /* don't run the init constructor) */\n      initializing = true;\n      var prototype = new ThisClass();\n      initializing = false;\n\n      function _superFactory(name,fn) {\n        return function() {\n          var tmp = this._super;\n\n          /* Add a new ._super() method that is the same method */\n          /* but on the super-class */\n          this._super = _super[name];\n\n          /* The method only need to be bound temporarily, so we */\n          /* remove it when we're done executing */\n          var ret = fn.apply(this, arguments);        \n          this._super = tmp;\n\n          return ret;\n        };\n      }\n\n      /* Copy the properties over onto the new prototype */\n      for (var name in prop) {\n        /* Check if we're overwriting an existing function */\n        prototype[name] = typeof prop[name] === \"function\" && \n          typeof _super[name] === \"function\" && \n            fnTest.test(prop[name]) ? \n              _superFactory(name,prop[name]) : \n              prop[name];\n      }\n      \n      /* The dummy class constructor */\n      function Class() {\n        /* All construction is actually done in the init method */\n        if ( !initializing && this.init ) {\n          this.init.apply(this, arguments);\n        }\n      }\n      \n      /* Populate our constructed prototype object */\n      Class.prototype = prototype;\n      \n      /* Enforce the constructor to be what we expect */\n      Class.prototype.constructor = Class;\n      /* And make this class extendable */\n      Class.extend = Q.Class.extend;\n      \n      /* If there are class-level Methods, add them to the class */\n      if(classMethods) {\n        Q._extend(Class,classMethods);\n      }\n\n      if(className) { \n        /* Save the class onto Q */\n        Q[className] = Class;\n\n        /* Let the class know its name */\n        Class.prototype.className = className;\n        Class.className = className;\n      }\n      \n      return Class;\n    };\n  }());\n    \n\n  // Event Handling\n  // ==============\n\n  // The `Q.Evented` class adds event handling onto the base `Q.Class` \n  // class. Evented objects can trigger events and other objects can\n  // bind to those events.\n  Q.Class.extend(\"Evented\",{\n\n    // Binds a callback to an event on this object. If you provide a\n    // `target` object, that object will add this event to it's list of\n    // binds, allowing it to automatically remove it when it is destroyed.\n    on: function(event,target,callback) {\n      if(Q._isArray(event) || event.indexOf(\",\") !== -1) {\n        event = Q._normalizeArg(event);\n        for(var i=0;i<event.length;i++) {\n          this.on(event[i],target,callback);\n        }\n        return;\n      }\n\n      // Handle the case where there is no target provided,\n      // swapping the target and callback parameters.\n      if(!callback) {\n        callback = target;\n        target = null;\n      }\n\n      // If there's still no callback, default to the event name\n      if(!callback) {\n        callback = event;\n      }\n      // Handle case for callback that is a string, this will\n      // pull the callback from the target object or from this\n      // object.\n      if(Q._isString(callback)) {\n        callback = (target || this)[callback];\n      }\n\n      // To keep `Q.Evented` objects from needing a constructor,\n      // the `listeners` object is created on the fly as needed.\n      // `listeners` keeps a list of callbacks indexed by event name\n      // for quick lookup. \n      this.listeners = this.listeners || {};\n      this.listeners[event] = this.listeners[event] || [];\n      this.listeners[event].push([ target || this, callback]);\n\n      // With a provided target, the target object keeps track of\n      // the events it is bound to, which allows for automatic \n      // unbinding on destroy.\n      if(target) {\n        if(!target.binds) { target.binds = []; }\n        target.binds.push([this,event,callback]);\n      }\n    },\n\n    // Triggers an event, passing in some optional additional data about\n    // the event. \n    trigger: function(event,data) {\n      // First make sure there are any listeners, then check for any listeners\n      // on this specific event, if not, early out.\n      if(this.listeners && this.listeners[event]) {\n        // Call each listener in the context of either the target passed into\n        // `on` or the object itself.\n        for(var i=0,len = this.listeners[event].length;i<len;i++) {\n          var listener = this.listeners[event][i];\n          listener[1].call(listener[0],data);\n        }\n      }\n    },\n    \n    // Unbinds an event. Can be called with 1, 2, or 3 parameters, each \n    // of which unbinds a more specific listener.\n    off: function(event,target,callback) {\n      // Without a target, remove all teh listeners.\n      if(!target) {\n        if(this.listeners[event]) {\n          delete this.listeners[event];\n        }\n      } else {\n        // If the callback is a string, find a method of the\n        // same name on the target.\n        if(Q._isString(callback) && target[callback]) {\n          callback = target[callback];\n        }\n        var l = this.listeners && this.listeners[event];\n        if(l) {\n          // Loop from the end to the beginning, which allows us\n          // to remove elements without having to affect the loop.\n          for(var i = l.length-1;i>=0;i--) {\n            if(l[i][0] === target) {\n              if(!callback || callback === l[i][1]) {\n                this.listeners[event].splice(i,1);\n              }\n            }\n          }\n        }\n      }\n    },\n\n    // `debind` is called to remove any listeners an object had\n    // on other objects. The most common case is when an object is\n    // destroyed you'll want all the event listeners to be removed\n    // for you.\n    debind: function() {\n       if(this.binds) {\n         for(var i=0,len=this.binds.length;i<len;i++) {\n           var boundEvent = this.binds[i],\n               source = boundEvent[0],\n               event = boundEvent[1];\n           source.off(event,this);\n         }\n       }\n     }\n\n   });\n\n\n   \n  // Components\n  // ==============\n  //\n  // Components are self-contained pieces of functionality that can be added onto and removed\n  // from objects. The allow for a more dynamic functionality tree than using inheritance (i.e.\n  // by favoring composition over inheritance) and are added and removed on the fly at runtime.\n  // (yes, I know everything in JS is at runtime, but you know what I mean, geez)\n  //\n  // Combining components with events makes it easy to create reusable pieces of\n  // functionality that can be decoupled from each other.\n\n\n  // The master list of registered components, indexed in an object by name.\n  Q.components = {};\n\n  // The base class for components. These are usually not derived directly but are instead\n  // created by calling `Q.register` to register a new component given a set of methods the \n  // component supports. Components are created automatically when they are added to a \n  // `Q.GameObject` with the `add` method.\n  //\n  // Many components also define an `added` method, which is called automatically by the\n  // `init` constructor after a component has been added to an object. This is a good time\n  // to add event listeners on the object.\n  Q.Evented.extend(\"Component\",{\n\n    // Components are created when they are added onto a `Q.GameObject` entity. The entity\n    // is directly extended with any methods inside of an `extend` property and then the \n    // component itself is added onto the entity as well. \n    init: function(entity) {\n      this.entity = entity;\n      if(this.extend) { Q._extend(entity,this.extend);   }\n      entity[this.name] = this;\n\n      entity.activeComponents.push(this.componentName);\n\n      if(entity.stage && entity.stage.addToList) {\n        entity.stage.addToList(this.componentName,entity);\n      }\n      if(this.added) { this.added(); }    \n    },\n\n    // `destroy` is called automatically when a component is removed from an entity. It is \n    // not called, however, when an entity is destroyed (for performance reasons).\n    // \n    // It's job is to remove any methods that were added with `extend` and then remove and\n    // debind itself from the entity. It will also call `destroyed` if the component has\n    // a method by that name.\n    destroy: function() {\n      if(this.extend) {\n        var extensions = Q._keys(this.extend);\n        for(var i=0,len=extensions.length;i<len;i++) {\n          delete this.entity[extensions[i]];\n        }\n      }\n      delete this.entity[this.name];\n      var idx = this.entity.activeComponents.indexOf(this.componentName);\n      if(idx !== -1) { \n        this.entity.activeComponents.splice(idx,1);\n\n        if(this.entity.stage && this.entity.stage.addToList) {\n          this.entity.stage.addToLists(this.componentName,this.entity);\n        }\n      }\n      this.debind();\n      if(this.destroyed) { this.destroyed(); }\n    }\n  });\n\n  // This is the base class most Quintus objects are derived from, it extends \n  // `Q.Evented` and adds component support to an object, allowing components to\n  // be added and removed from an object. It also defines a destroyed method\n  // which will debind the object, remove it from it's parent (usually a scene)\n  // if it has one, and trigger a destroyed event.\n  Q.Evented.extend(\"GameObject\",{\n\n    // Simple check to see if a component already exists\n    // on an object by searching for a property of the same name.\n    has: function(component) {\n      return this[component] ? true : false; \n    },\n\n\n    // Adds one or more components to an object. Accepts either \n    // a comma separated string or an array of strings that map\n    // to component names.\n    //\n    // Instantiates a new component object of the correct type\n    // (if the component exists) and then triggers an addComponent\n    // event.\n    //\n    // Returns the object to allow chaining.\n    add: function(components) {\n      components = Q._normalizeArg(components);\n      if(!this.activeComponents) { this.activeComponents = []; }\n      for(var i=0,len=components.length;i<len;i++) {\n        var name = components[i],\n            Comp = Q.components[name];\n        if(!this.has(name) && Comp) { \n          var c = new Comp(this); \n          this.trigger('addComponent',c);\n        }\n      }\n      return this;\n    }, \n\n    // Removes one or more components from an object. Accepts the\n    // same style of parameters as `add`. Triggers a delComponent event\n    // and and calls destroy on the component.\n    //\n    // Returns the element to allow chaining.\n    del: function(components) {\n      components = Q._normalizeArg(components);\n      for(var i=0,len=components.length;i<len;i++) {\n        var name = components[i];\n        if(name && this.has(name)) { \n          this.trigger('delComponent',this[name]);\n          this[name].destroy(); \n        }\n      }\n      return this;\n    },\n\n    // Destroys the object by calling debind and removing the\n    // object from it's parent. Will trigger a destroyed event\n    // callback.\n    destroy: function() {\n      if(this.isDestroyed) { return; }\n      this.trigger('destroyed');\n      this.debind();\n      if(this.stage && this.stage.remove) {\n        this.stage.remove(this);\n      }\n      this.isDestroyed = true;\n      if(this.destroyed) { this.destroyed(); }\n    }\n  });\n\n  // This registers a component with the engine, making it available to `Q.GameObject`'s \n  // This creates a new descendent class of `Q.Component` with new methods added in.\n  Q.component = function(name,methods) {\n    if(!methods) { return Q.components[name]; }\n    methods.name = name;\n    methods.componentName = \".\" + name;\n    return (Q.components[name] = Q.Component.extend(name + \"Component\",methods));\n  };\n\n\n  // Generic Game State object that can be used to\n  // track of the current state of the Game, for example when the player starts\n  // a new game you might want to keep track of their score and remaining lives:\n  //\n  //     Q.reset({ score: 0, lives: 2 });\n  //\n  // Then in your game might want to add to the score:\n  //     \n  //      Q.state.inc(\"score\",50);\n  //\n  // In your hud, you can listen for change events on the state to update your \n  // display:\n  //\n  //      Q.state.on(\"change.score\",function() { .. update the score display .. });\n  //\n  Q.GameObject.extend(\"GameState\",{\n    init: function(p) {\n      this.p = Q._extend({},p);\n      this.listeners = {};\n    },\n\n    // Resets the state to value p\n    reset: function(p) { this.init(p); this.trigger(\"reset\"); },\n    \n    // Internal helper method to set an individual property\n    _triggerProperty: function(value,key) {\n      if(this.p[key] !== value) {\n        this.p[key] = value;\n        this.trigger(\"change.\" + key,value);\n      }\n    },\n\n    // Set one or more properties, trigger events on those\n    // properties changing\n    set: function(properties,value) {\n      if(Q._isObject(properties)) {\n        Q._each(properties,this._triggerProperty,this);\n      } else {\n        this._triggerProperty(value,properties);\n      }\n      this.trigger(\"change\");\n    },\n\n    // Increment an individual property by amount\n    inc: function(property,amount) {\n      this.set(property,this.get(property) + amount);\n    },\n\n    // Increment an individual property by amount\n    dec: function(property,amount) {\n      this.set(property,this.get(property) - amount);\n    },\n\n    // Return an individual property\n    get: function(property) {\n      return this.p[property];\n    }\n  });\n\n  // The instance of the Q.stage property\n  Q.state = new Q.GameState();\n\n  // Reset the game state and unbind all state events\n  Q.reset = function() { Q.state.reset(); };\n\n\n  // Canvas Methods\n  // ==============\n  //\n  // The `setup` and `clear` method are the only two canvas-specific methods in \n  // the core of Quintus. `imageData`  also uses canvas but it can be used in\n  // any type of game.\n\n\n  // Setup will either create a new canvas element and append it\n  // to the body of the document or use an existing one. It will then\n  // pull out the width and height of the canvas for engine use.\n  //\n  // It also adds a wrapper container around the element.\n  //\n  // If the `maximize` is set to true, the canvas element is maximized\n  // on the page and the scroll trick is used to try to get the address bar away.\n  //\n  // The engine will also resample the game to CSS dimensions at twice pixel\n  // dimensions if the `resampleWidth` or `resampleHeight` options are set.\n  //\n  // TODO: add support for auto-resize w/ engine event notifications, remove\n  // jQuery.\n\n  Q.touchDevice = ('ontouchstart' in document);\n\n  Q.setup = function(id, options) {\n    if(Q._isObject(id)) {\n      options = id;\n      id = null;\n    }\n    options = options || {};\n    id = id || \"quintus\";\n\n    if(Q._isString(id)) {\n      Q.el = document.getElementById(id);\n    } else {\n      Q.el = id;\n    }\n\n    if(!Q.el) {\n      Q.el = document.createElement(\"canvas\");\n      Q.el.width = options.width || 320;\n      Q.el.height = options.height || 420;\n      Q.el.id = id;\n\n      document.body.appendChild(Q.el);\n    }\n\n    var w = parseInt(Q.el.width,10),\n        h = parseInt(Q.el.height,10);\n\n    var maxWidth = options.maxWidth || 5000,\n        maxHeight = options.maxHeight || 5000,\n        resampleWidth = options.resampleWidth,\n        resampleHeight = options.resampleHeight,\n        upsampleWidth = options.upsampleWidth,\n        upsampleHeight = options.upsampleHeight;\n\n    if(options.maximize === true || (Q.touchDevice && options.maximize === 'touch'))  {\n      document.body.style.padding = 0;\n      document.body.style.margin = 0;\n\n      w = Math.min(window.innerWidth,maxWidth);\n      h = Math.min(window.innerHeight - 5,maxHeight);\n\n      if(Q.touchDevice) {\n        Q.el.style.height = (h*2) + \"px\";\n        window.scrollTo(0,1);\n\n        w = Math.min(window.innerWidth,maxWidth);\n        h = Math.min(window.innerHeight,maxHeight);\n      }\n    } else if(Q.touchDevice) {\n      window.scrollTo(0,1);\n    }\n\n    if((upsampleWidth && w <= upsampleWidth) ||\n       (upsampleHeight && h <= upsampleHeight)) {\n      Q.el.style.height = h + \"px\";\n      Q.el.style.width = w + \"px\";\n      Q.el.width = w * 2;\n      Q.el.height = h * 2;\n    }\n    else if(((resampleWidth && w > resampleWidth) ||\n        (resampleHeight && h > resampleHeight)) && \n       Q.touchDevice) { \n      Q.el.style.height = h + \"px\";\n      Q.el.style.width = w + \"px\";\n      Q.el.width = w / 2;\n      Q.el.height = h / 2;\n    } else {\n      Q.el.style.height = h + \"px\";\n      Q.el.style.width = w + \"px\";\n      Q.el.width = w;\n      Q.el.height = h;\n    }\n\n    var elParent = Q.el.parentNode;\n\n    if(elParent) {\n      Q.wrapper = document.createElement(\"div\");\n      Q.wrapper.id = id + '_container';\n      Q.wrapper.style.width = w + \"px\";\n      Q.wrapper.style.margin = \"0 auto\";\n      Q.wrapper.style.position = \"relative\";\n\n\n      elParent.insertBefore(Q.wrapper,Q.el);\n      Q.wrapper.appendChild(Q.el);\n    }\n    \n    Q.el.style.position = 'relative';\n\n    Q.ctx = Q.el.getContext && \n            Q.el.getContext(\"2d\");\n\n\n    Q.width = parseInt(Q.el.width,10);\n    Q.height = parseInt(Q.el.height,10);\n    Q.cssWidth = w;\n    Q.cssHeight = h;\n\n    window.addEventListener('orientationchange',function() {\n      setTimeout(function() { window.scrollTo(0,1); }, 0);\n    });\n\n    return Q;\n  };\n\n\n  // Clear the canvas completely.\n  Q.clear = function() {\n    if(Q.clearColor) {\n      Q.ctx.globalAlpha = 1;\n      Q.ctx.fillStyle = Q.clearColor;\n      Q.ctx.fillRect(0,0,Q.width,Q.height);\n    } else {\n      Q.ctx.clearRect(0,0,Q.width,Q.height);\n    }\n  };\n\n\n  // Return canvas image data given an Image object.\n  Q.imageData = function(img) {\n    var canvas = document.createElement(\"canvas\");\n    \n    canvas.width = img.width;\n    canvas.height = img.height;\n\n    var ctx = canvas.getContext(\"2d\");\n    ctx.drawImage(img,0,0);\n\n    return ctx.getImageData(0,0,img.width,img.height);\n  };\n\n  \n\n  // Asset Loading Support\n  // =====================\n  //\n  // The engine supports loading assets of different types using\n  // `load` or `preload`. Assets are stored by their name so the \n  // same asset won't be loaded twice if it already exists.\n\n  // Augmentable list of asset types, loads a specific asset \n  // type if the file type matches, otherwise defaults to a Ajax\n  // load of the data.\n  //\n  // You can new types of assets based on file extension by\n  // adding to `assetTypes` and adding a method called\n  // loadAssetTYPENAME where TYPENAME is the name of the\n  // type you added in.\n  Q.assetTypes = { \n    png: 'Image', jpg: 'Image', gif: 'Image', jpeg: 'Image',\n    ogg: 'Audio', wav: 'Audio', m4a: 'Audio', mp3: 'Audio'\n  };\n\n\n  // Determine the type of asset based on the lookup table above\n  Q.assetType = function(asset) {\n    /* Determine the lowercase extension of the file */\n    var fileParts = asset.split(\".\"),\n        fileExt = fileParts[fileParts.length-1].toLowerCase();\n\n    // Use the web audio loader instead of the regular loader\n    // if it's supported.\n    var fileType =  Q.assetTypes[fileExt];\n    if(fileType === 'Audio' && Q.audio && Q.audio.type === \"WebAudio\") {\n      fileType = 'WebAudio';\n    }\n\n    /* Lookup the asset in the assetTypes hash, or return other */\n    return fileType || 'Other';\n  };\n\n  // Either return an absolute URL, \n  // or add a base to a relative URL\n  Q.assetUrl = function(base,url) {\n    if(/^https?:\\/\\//.test(url) || url[0] === \"/\") {\n      return url;\n    } else {\n      return base + url;\n    }\n  };\n\n  // Loader for Images, creates a new `Image` object and uses the \n  // load callback to determine the image has been loaded\n  Q.loadAssetImage = function(key,src,callback,errorCallback) {\n    var img = new Image();\n    img.onload = function() {  callback(key,img); };\n    img.onerror = errorCallback;\n    img.src = Q.assetUrl(Q.options.imagePath,src);\n  };\n\n\n  // List of mime types given an audio file extension, used to \n  // determine what sound types the browser can play using the \n  // built-in `Sound.canPlayType`\n  Q.audioMimeTypes = { mp3: 'audio/mpeg', \n                       ogg: 'audio/ogg; codecs=\"vorbis\"',\n                       m4a: 'audio/m4a',\n                       wav: 'audio/wav' };\n\n  Q._audioAssetExtension = function() {\n    if(Q._audioAssetPreferredExtension) { return Q._audioAssetPreferredExtension; }\n\n    var snd = new Audio();\n\n    /* Find a supported type */\n    return Q._audioAssetPreferredExtension = \n      Q._detect(Q.options.audioSupported,\n         function(extension) {\n         return snd.canPlayType(Q.audioMimeTypes[extension]) ? \n                                extension : null;\n      });\n  };\n\n  // Loader for Audio assets. By default chops off the extension and \n  // will automatically determine which of the supported types is \n  // playable by the browser and load that type.\n  //\n  // Which types are available are determined by the file extensions\n  // listed in the Quintus `options.audioSupported`\n  Q.loadAssetAudio = function(key,src,callback,errorCallback) {\n    if(!document.createElement(\"audio\").play || !Q.options.sound) {\n      callback(key,null);\n      return;\n    }\n\n    var baseName = Q._removeExtension(src),\n        extension = Q._audioAssetExtension(),\n        filename = null,\n        snd = new Audio();\n\n    /* No supported audio = trigger ok callback anyway */\n    if(!extension) {\n      callback(key,null);\n      return;\n    }\n\n    snd.addEventListener(\"error\",errorCallback);\n\n    // Don't wait for canplaythrough on mobile\n    if(!Q.touchDevice) { \n      snd.addEventListener('canplaythrough',function() { \n        callback(key,snd); \n      });\n    }\n    snd.src =  Q.assetUrl(Q.options.audioPath,baseName + \".\" + extension);\n    snd.load();\n\n    if(Q.touchDevice) {\n      callback(key,snd);\n    }\n  };\n\n  Q.loadAssetWebAudio = function(key,src,callback,errorCallback) {\n    var request = new XMLHttpRequest(),\n        baseName = Q._removeExtension(src),\n        extension = Q._audioAssetExtension();\n\n    request.open(\"GET\", Q.assetUrl(Q.options.audioPath,baseName + \".\" + extension), true);\n    request.responseType = \"arraybuffer\";\n\n    // Our asynchronous callback\n    request.onload = function() {\n      var audioData = request.response;\n\n      Q.audioContext.decodeAudioData(request.response, function(buffer) {\n        callback(key,buffer);\n      }, errorCallback);\n    };\n    request.send();\n\n  };\n\n  // Loader for other file types, just store the data\n  // returned from an Ajax call.\n  Q.loadAssetOther = function(key,src,callback,errorCallback) {\n    var request = new XMLHttpRequest();\n\n    var fileParts = src.split(\".\"),\n        fileExt = fileParts[fileParts.length-1].toLowerCase();\n\n    request.onreadystatechange = function() {\n      if(request.readyState === 4) {\n        if(request.status === 200) {\n          if(fileExt === 'json') {\n            callback(key,JSON.parse(request.responseText));\n          } else {\n            callback(key,request.responseText);\n          }\n        } else {\n          errorCallback();\n        }\n      }\n    };\n\n    request.open(\"GET\",Q.options.dataPath + src, true);\n    request.send(null);\n  };\n\n  // Helper method to return a name without an extension\n  Q._removeExtension = function(filename) {\n    return filename.replace(/\\.(\\w{3,4})$/,\"\");\n  };\n\n  // Asset hash storing any loaded assets\n  Q.assets = {};\n\n\n  // Getter method to return an asset by its name.\n  //\n  // Asset names default to their filenames, but can be overridden\n  // by passing a hash to `load` to set different names.\n  Q.asset = function(name) {\n    return Q.assets[name];\n  };\n\n  // Load assets, and call our callback when done.\n  //\n  // Also optionally takes a `progressCallback` which will be called \n  // with the number of assets loaded and the total number of assets\n  // to allow showing of a progress. \n  //\n  // Assets can be passed in as an array of file names, and Quintus\n  // will use the file names as the name for reference, or as a hash of \n  // `{ name: filename }`. \n  //\n  // Example usage:\n  //     Q.load(['sprites.png','sprites.,json'],function() {\n  //        Q.stageScene(\"level1\"); // or something to start the game.\n  //     });\n  Q.load = function(assets,callback,options) {\n    var assetObj = {};\n\n    /* Make sure we have an options hash to work with */\n    if(!options) { options = {}; }\n\n    /* Get our progressCallback if we have one */\n    var progressCallback = options.progressCallback;\n\n    var errors = false,\n        errorCallback = function(itm) {\n          errors = true;\n          (options.errorCallback  ||\n           function(itm) { throw(\"Error Loading: \" + itm ); })(itm);\n        };\n\n    /* Convert to an array if it's a string */\n    if(Q._isString(assets)) {\n      assets = Q._normalizeArg(assets);\n    }\n\n    /* If the user passed in an array, convert it */\n    /* to a hash with lookups by filename */\n    if(Q._isArray(assets)) { \n      Q._each(assets,function(itm) {\n        if(Q._isObject(itm)) {\n          Q._extend(assetObj,itm);\n        } else {\n          assetObj[itm] = itm;\n        }\n      });\n    } else {\n      /* Otherwise just use the assets as is */\n      assetObj = assets;\n    }\n\n    /* Find the # of assets we're loading */\n    var assetsTotal = Q._keys(assetObj).length,\n        assetsRemaining = assetsTotal;\n\n    /* Closure'd per-asset callback gets called */\n    /* each time an asset is successfully loadded */\n    var loadedCallback = function(key,obj,force) {\n      if(errors) { return; }\n\n      // Prevent double callbacks (I'm looking at you Firefox, canplaythrough\n      if(!Q.assets[key]||force) {\n\n        /* Add the object to our asset list */\n        Q.assets[key] = obj;\n\n        /* We've got one less asset to load */\n        assetsRemaining--;\n\n        /* Update our progress if we have it */\n        if(progressCallback) { \n           progressCallback(assetsTotal - assetsRemaining,assetsTotal); \n        }\n      }\n\n      /* If we're out of assets, call our full callback */\n      /* if there is one */\n      if(assetsRemaining === 0 && callback) {\n        /* if we haven't set up our canvas element yet, */\n        /* assume we're using a canvas with id 'quintus' */\n        callback.apply(Q); \n      }\n    };\n\n    /* Now actually load each asset */\n    Q._each(assetObj,function(itm,key) {\n\n      /* Determine the type of the asset */\n      var assetType = Q.assetType(itm);\n\n      /* If we already have the asset loaded, */\n      /* don't load it again */\n      if(Q.assets[key]) {\n        loadedCallback(key,Q.assets[key],true);\n      } else {\n        /* Call the appropriate loader function */\n        /* passing in our per-asset callback */\n        /* Dropping our asset by name into Q.assets */\n        Q[\"loadAsset\" + assetType](key,itm,\n                                   loadedCallback,\n                                   function() { errorCallback(itm); });\n      }\n    });\n\n  };\n\n  // Array to store any assets that need to be \n  // preloaded\n  Q.preloads = [];\n  \n  // Let us gather assets to load at a later time,\n  // and then preload them all at the same time with\n  // a single callback. Options are passed through to the\n  // Q.load method if used.\n  //\n  // Example usage:\n  //      Q.preload(\"sprites.png\");\n  //      ...\n  //      Q.preload(\"sprites.json\");\n  //      ...\n  //\n  //      Q.preload(function() {\n  //         Q.stageScene(\"level1\"); // or something to start the game\n  //      });\n  Q.preload = function(arg,options) {\n    if(Q._isFunction(arg)) {\n      Q.load(Q._uniq(Q.preloads),arg,options);\n      Q.preloads = [];\n    } else {\n      Q.preloads = Q.preloads.concat(arg);\n    }\n  };\n\n\n  // Math Methods\n  // ==============\n  //\n  // Math methods, for rotating and scaling points\n\n  // A list of matrices available\n  Q.matrices2d = [];\n\n  Q.matrix2d = function() {\n    return Q.matrices2d.length > 0 ? Q.matrices2d.pop().identity() : new Q.Matrix2D();\n  };\n\n  // A 2D matrix class, optimized for 2D points,\n  // where the last row of the matrix will always be 0,0,1 \n  // Good Docs where: \n  //    https://github.com/heygrady/transform/wiki/calculating-2d-matrices\n  Q.Matrix2D = Q.Class.extend({\n    init: function(source) {\n\n      if(source) {\n        this.m = [];\n        this.clone(source);\n      } else {\n        this.m = [1,0,0,0,1,0];\n      }\n    },\n\n    // Turn this matrix into the identity\n    identity: function() {\n      var m = this.m;\n      m[0] = 1; m[1] = 0; m[2] = 0;\n      m[3] = 0; m[4] = 1; m[5] = 0;\n      return this;\n    },\n\n    // Clone another matrix into this one\n    clone: function(matrix) {\n      var d = this.m, s = matrix.m;\n      d[0]=s[0]; d[1]=s[1]; d[2] = s[2];\n      d[3]=s[3]; d[4]=s[4]; d[5] = s[5];\n      return this;\n    },\n\n    // a * b = \n    //   [ [ a11*b11 + a12*b21 ], [ a11*b12 + a12*b22 ], [ a11*b31 + a12*b32 + a13 ] ,\n    //   [ a21*b11 + a22*b21 ], [ a21*b12 + a22*b22 ], [ a21*b31 + a22*b32 + a23 ] ]\n    multiply: function(matrix) {\n      var a = this.m, b = matrix.m;\n\n      var m11 = a[0]*b[0] + a[1]*b[3];\n      var m12 = a[0]*b[1] + a[1]*b[4];\n      var m13 = a[0]*b[2] + a[1]*b[5] + a[2];\n\n      var m21 = a[3]*b[0] + a[4]*b[3];\n      var m22 = a[3]*b[1] + a[4]*b[4];\n      var m23 = a[3]*b[2] + a[4]*b[5] + a[5];\n\n      a[0]=m11; a[1]=m12; a[2] = m13;\n      a[3]=m21; a[4]=m22; a[5] = m23;\n      return this;\n    },\n\n    // Multiply this matrix by a rotation matrix rotated radians radians \n    rotate: function(radians) {\n      if(radians === 0) { return this; }\n      var cos = Math.cos(radians),\n          sin = Math.sin(radians),\n          m = this.m;\n\n      var m11 = m[0]*cos  + m[1]*sin;\n      var m12 = m[0]*-sin + m[1]*cos;\n\n      var m21 = m[3]*cos  + m[4]*sin;\n      var m22 = m[3]*-sin + m[4]*cos;\n\n      m[0] = m11; m[1] = m12; // m[2] == m[2]\n      m[3] = m21; m[4] = m22; // m[5] == m[5]\n      return this;\n    },\n\n    // Helper method to rotate by a set number of degrees\n    rotateDeg: function(degrees) {\n      if(degrees === 0) { return this; }\n      return this.rotate(Math.PI * degrees / 180);\n    },\n\n    // Multiply this matrix by a scaling matrix scaling sx and sy\n    scale: function(sx,sy) {\n      var m = this.m;\n      if(sy === void 0) { sy = sx; }\n\n      m[0] *= sx;\n      m[1] *= sy;\n      m[3] *= sx;\n      m[4] *= sy;\n      return this;\n    },\n\n\n    // Multiply this matrix by a translation matrix translate by tx and ty\n    translate: function(tx,ty) {\n      var m = this.m;\n\n      m[2] += m[0]*tx + m[1]*ty;\n      m[5] += m[3]*tx + m[4]*ty;\n      return this;\n    },\n\n    // Memory Hoggy version\n    transform: function(x,y) {\n      return [ x * this.m[0] + y * this.m[1] + this.m[2], \n               x * this.m[3] + y * this.m[4] + this.m[5] ];\n    },\n\n    // Transform an object with an x and y property by this Matrix\n    transformPt: function(obj) {\n      var x = obj.x, y = obj.y;\n\n      obj.x = x * this.m[0] + y * this.m[1] + this.m[2];\n      obj.y = x * this.m[3] + y * this.m[4] + this.m[5];\n\n      return obj;\n    },\n\n    // Transform an array with an x and y property by this Matrix\n    transformArr: function(inArr,outArr) {\n      var x = inArr[0], y = inArr[1];\n      \n      outArr[0] = x * this.m[0] + y * this.m[1] + this.m[2];\n      outArr[1] = x * this.m[3] + y * this.m[4] + this.m[5];\n\n      return outArr;\n    },\n\n\n    // Return just the x component by this Matrix\n    transformX: function(x,y) {\n      return x * this.m[0] + y * this.m[1] + this.m[2];\n    },\n\n    // Return just the y component by this Matrix\n    transformY: function(x,y) {\n      return x * this.m[3] + y * this.m[4] + this.m[5];\n    },\n\n    // Release this Matrix to be reused\n    release: function() {\n      Q.matrices2d.push(this);\n      return null;\n    },\n\n    setContextTransform: function(ctx) {\n      var m = this.m;\n      // source:\n      //  m[0] m[1] m[2]\n      //  m[3] m[4] m[5]\n      //  0     0   1\n      //\n      // destination:\n      //  m11  m21  dx\n      //  m12  m22  dy\n      //  0    0    1\n      //  setTransform(m11, m12, m21, m22, dx, dy)\n      ctx.transform(m[0],m[3],m[1],m[4],m[2],m[5]);\n      //ctx.setTransform(m[0],m[1],m[2],m[3],m[4],m[5]);\n    }\n\n  });\n\n  // And that's it..\n  // ===============\n  //\n  // Return the `Q` object from the `Quintus()` factory method. Create awesome games. Repeat.\n  return Q;\n};\n\n// Lastly, add in the `requestAnimationFrame` shim, if necessary. Does nothing \n// if `requestAnimationFrame` is already on the `window` object.\n(function() {\n    var lastTime = 0;\n    var vendors = ['ms', 'moz', 'webkit', 'o'];\n    for(var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {\n        window.requestAnimationFrame = window[vendors[x]+'RequestAnimationFrame'];\n        window.cancelAnimationFrame = \n          window[vendors[x]+'CancelAnimationFrame'] || window[vendors[x]+'CancelRequestAnimationFrame'];\n    }\n \n    if (!window.requestAnimationFrame) {\n        window.requestAnimationFrame = function(callback, element) {\n            var currTime = new Date().getTime();\n            var timeToCall = Math.max(0, 16 - (currTime - lastTime));\n            var id = window.setTimeout(function() { callback(currTime + timeToCall); }, \n              timeToCall);\n            lastTime = currTime + timeToCall;\n            return id;\n        };\n    }\n \n    if (!window.cancelAnimationFrame) {\n        window.cancelAnimationFrame = function(id) {\n            clearTimeout(id);\n        };\n    }\n}());\n\n\n\n/*global Quintus:false, AudioContext:false, window:false */\n\nQuintus.Audio = function(Q) {\n\n  Q.audio = {\n    channels: [],\n    channelMax:  Q.options.channelMax || 10,\n    active: {},\n    play: function() {}\n  };\n\n\n  Q.hasWebAudio = (typeof AudioContext !== \"undefined\") || (typeof webkitAudioContext !== \"undefined\");\n\n  if(Q.hasWebAudio) { \n    if(typeof AudioContext !== \"undefined\") {\n      Q.audioContext = new AudioContext();\n    } else {\n      Q.audioContext = new window.webkitAudioContext();\n    }\n  }\n\n  Q.enableSound = function() {\n    var hasTouch =  !!('ontouchstart' in window);\n\n    if(Q.hasWebAudio) {\n      Q.audio.enableWebAudioSound();\n    } else {\n      Q.audio.enableHTML5Sound();\n    }\n    return Q;\n  };\n\n  Q.audio.enableWebAudioSound = function() {\n    Q.audio.type = \"WebAudio\";\n\n    Q.audio.soundID = 0;\n\n    Q.audio.playingSounds = {};\n\n    Q.audio.removeSound = function(soundID) {\n      delete Q.audio.playingSounds[soundID];\n    };\n\n    // Play a single sound, optionally debounced \n    // to prevent repeated plays in a short time\n    Q.audio.play = function(s,options) {\n      var now = new Date().getTime();\n\n      // See if this audio file is currently being debounced, if \n      // it is, don't do anything and just return\n      if(Q.audio.active[s] && Q.audio.active[s] > now) { return; }\n\n      // If any options were passed in, check for a debounce,\n      // which is the number of milliseconds to debounce this sound\n      if(options && options['debounce']) {\n        Q.audio.active[s] = now + options['debounce'];\n      } else {\n        delete Q.audio.active[s];\n      }\n\n      var soundID = Q.audio.soundID++;\n\n      var source = Q.audioContext.createBufferSource();\n      source.buffer = Q.asset(s);\n      source.connect(Q.audioContext.destination);\n      if(options && options['loop']) {\n        source.loop = true;\n      } else {\n        setTimeout(function() {\n          Q.audio.removeSound(soundID);\n        },source.buffer.duration * 1000);\n      }\n      source.assetName = s;\n      if(source.start) { source.start(0); } else { source.noteOn(0); }\n\n      Q.audio.playingSounds[soundID] = source;\n\n\n    };\n\n    Q.audio.stop = function(s) {\n      for(var key in Q.audio.playingSounds) {\n        var snd = Q.audio.playingSounds[key];\n        if(!s || s === snd.assetName) {\n          if(snd.stop) { snd.stop(0);  } else {  snd.noteOff(0); }\n        }\n      }\n    };\n\n  };\n\n  Q.audio.enableHTML5Sound = function() {\n    Q.audio.type = \"HTML5\";\n\n    for (var i=0;i<Q.audio.channelMax;i++) {    \n      Q.audio.channels[i] = {};\n      Q.audio.channels[i]['channel'] = new Audio(); \n      Q.audio.channels[i]['finished'] = -1;\t\n    }\n\n    // Play a single sound, optionally debounced \n    // to prevent repeated plays in a short time\n    Q.audio.play = function(s,options) {\n      var now = new Date().getTime();\n\n      // See if this audio file is currently being debounced, if \n      // it is, don't do anything and just return\n      if(Q.audio.active[s] && Q.audio.active[s] > now) { return; }\n\n      // If any options were passed in, check for a debounce,\n      // which is the number of milliseconds to debounce this sound\n      if(options && options['debounce']) {\n        Q.audio.active[s] = now + options['debounce'];\n      } else {\n        delete Q.audio.active[s];\n      }\n\n      // Find a free audio channel and play the sound\n      for (var i=0;i<Q.audio.channels.length;i++) {\n        // Check the channel is either finished or not looping\n        if (!Q.audio.channels[i]['loop'] && Q.audio.channels[i]['finished'] < now) {\t\n\n          Q.audio.channels[i]['channel'].src = Q.asset(s).src;\n\n          // If we're looping - just set loop to true to prevent this channcel\n          // from being used.\n          if(options && options['loop']) { \n            Q.audio.channels[i]['loop'] = true;\n            Q.audio.channels[i]['channel'].loop = true;\n          } else {\n            Q.audio.channels[i]['finished'] = now + Q.asset(s).duration*1000;\n          }\n          Q.audio.channels[i]['channel'].load();\n          Q.audio.channels[i]['channel'].play();\n          break;\n        }\n      }\n    };\n\n    // Stop a single sound asset or stop all sounds currently playing\n    Q.audio.stop = function(s) {\n      var src = s ? Q.asset(s).src : null;\n      var tm = new Date().getTime();\n      for (var i=0;i<Q.audio.channels.length;i++) {\n        if ((!src || Q.audio.channels[i]['channel'].src === src) && \n            (Q.audio.channels[i]['loop'] || Q.audio.channels[i]['finished'] >= tm)) {\n          Q.audio.channels[i]['channel'].pause();\n          Q.audio.channels[i]['loop'] = false;\n        }\n      }\n    };\n\n  };\n\n};\n  \n\n/*global Quintus:false */\n\nQuintus.UI = function(Q) {\n  if(Q._isUndefined(Quintus.Touch)) {\n    throw \"Quintus.UI requires Quintus.Touch Module\";\n  }\n\n  Q.UI = {};\n\n  // Draw a rounded rectangle centered on 0,0\n  Q.UI.roundRect = function(ctx, rect) {\n    ctx.beginPath();\n    ctx.moveTo(-rect.cx + rect.radius, -rect.cy);\n    ctx.lineTo(-rect.cx + rect.w - rect.radius, -rect.cy);\n    ctx.quadraticCurveTo(-rect.cx + rect.w, -rect.cy, -rect.cx + rect.w, -rect.cy + rect.radius);\n    ctx.lineTo(-rect.cx + rect.w, -rect.cy + rect.h - rect.radius);\n    ctx.quadraticCurveTo(-rect.cx + rect.w, \n                         -rect.cy + rect.h, \n                         -rect.cx + rect.w - rect.radius, \n                         -rect.cy + rect.h);\n    ctx.lineTo(-rect.cx + rect.radius, -rect.cy + rect.h);\n    ctx.quadraticCurveTo(-rect.cx, -rect.cy + rect.h, -rect.cx, -rect.cy + rect.h - rect.radius);\n    ctx.lineTo(-rect.cx, -rect.cy + rect.radius);\n    ctx.quadraticCurveTo(-rect.cx, -rect.cy, -rect.cx + rect.radius, -rect.cy);\n    ctx.closePath();\n  };\n\n\n\n  Q.UI.Container = Q.Sprite.extend(\"UI.Container\", {\n    init: function(p,defaults) {\n      var adjustedP = Q._clone(p||{}),\n          match;\n\n      if(p && Q._isString(p.w) && (match = p.w.match(/^[0-9]+%$/))) {\n        adjustedP.w = parseInt(p.w,10) * Q.width / 100;         \n        adjustedP.x = Q.width/2 - adjustedP.w/2;\n      }\n\n      if(p && Q._isString(p.h) && (match = p.h.match(/^[0-9]+%$/))) {\n        adjustedP.h = parseInt(p.h,10) * Q.height / 100;         \n        adjustedP.y = Q.height /2 - adjustedP.h/2;\n      }\n\n      this._super(adjustedP,{\n        opacity: 1,\n        hidden: false, // Set to true to not show the container\n        fill:   null, // Set to color to add background\n        highlight:   null, // Set to color to for button\n        radius: 5, // Border radius\n        stroke: \"#000\", \n        border: false, // Set to a width to show a border\n        shadow: false, // Set to true or a shadow offest\n        shadowColor: false, // Set to a rgba value for the shadow\n        type: Q.SPRITE_NONE\n      });\n\n    },\n\n    insert: function(obj) {\n      this.stage.insert(obj,this);\n      return obj;\n    },\n\n    fit: function(paddingY,paddingX) {\n      if(this.children.length === 0) { return; }\n\n      if(paddingY === void 0) { paddingY = 0; }\n      if(paddingX === void 0) { paddingX = paddingY; }\n\n      var minX = Infinity,\n          minY = Infinity,\n          maxX = -Infinity,\n          maxY = -Infinity;\n\n      for(var i =0;i < this.children.length;i++) {\n        var obj = this.children[i];\n        var minObjX = obj.p.x - obj.p.cx,\n            minObjY = obj.p.y - obj.p.cy,\n            maxObjX = obj.p.x - obj.p.cx + obj.p.w,\n            maxObjY = obj.p.y - obj.p.cy + obj.p.h;\n\n        if(minObjX < minX) { minX = minObjX; }\n        if(minObjY < minY) { minY = minObjY; }\n\n        if(maxObjX > maxX) { maxX = maxObjX; }\n        if(maxObjY > maxY) { maxY = maxObjY; }\n\n      }\n\n      this.p.cx = -minX + paddingX;\n      this.p.cy = -minY + paddingY;\n      this.p.w = maxX - minX + paddingX * 2;\n      this.p.h = maxY - minY + paddingY * 2;\n    },\n\n    addShadow: function(ctx) {\n      if(this.p.shadow) {\n        var shadowAmount = Q._isNumber(this.p.shadow) ? this.p.shadow : 5;\n        ctx.shadowOffsetX=shadowAmount;\n        ctx.shadowOffsetY=shadowAmount;\n        ctx.shadowColor = this.p.shadowColor || \"rgba(0,0,50,0.1)\";\n      }\n    },\n\n    clearShadow: function(ctx) {\n      ctx.shadowColor = \"transparent\";\n    },\n\n    drawRadius: function(ctx) {\n      Q.UI.roundRect(ctx,this.p);\n      this.addShadow(ctx);\n      ctx.fill();\n      if(this.p.border) {\n        this.clearShadow(ctx);\n        ctx.lineWidth = this.p.border;\n        ctx.stroke();\n      }\n    },\n\n    drawSquare: function(ctx) {\n      this.addShadow(ctx);\n      if(this.p.fill) { \n        ctx.fillRect(-this.p.cx,-this.p.cy,\n                      this.p.w,this.p.h);\n      }\n\n      if(this.p.border) {\n        this.clearShadow(ctx);\n        ctx.lineWidth = this.p.border;\n        ctx.strokeRect(-this.p.cx,-this.p.cy,\n                        this.p.w,this.p.h);\n      }\n    },\n\n    draw: function(ctx) {\n      if(this.p.hidden) { return false; }\n      if(!this.p.border && !this.p.fill) { return; }\n\n      ctx.globalAlpha = this.p.opacity;\n      if(this.p.frame === 1 && this.p.highlight) {\n        ctx.fillStyle = this.p.highlight;\n      } else {\n        ctx.fillStyle = this.p.fill;\n      }\n      ctx.strokeStyle = this.p.stroke;\n\n      if(this.p.radius > 0) { \n        this.drawRadius(ctx);\n      } else {\n        this.drawSquare(ctx);\n      }\n\n    }\n  });\n\n\n  Q.UI.Text = Q.Sprite.extend(\"UI.Text\", {\n    init: function(p,defaultProps) {\n      this._super(Q._defaults(p||{},defaultProps),{\n        type: Q.SPRITE_UI,\n        size: 24\n      });\n\n      //this.el = document.createElement(\"canvas\");\n      //this.ctx = this.el.getContext(\"2d\");\n\n      if(this.p.label) {\n        this.calcSize();\n      }\n\n      //this.prerender();\n    },\n\n    calcSize: function() {\n      this.setFont(Q.ctx);\n      this.splitLabel = this.p.label.split(\"\\n\");\n      var maxLabel = \"\";\n      for(var i = 0;i < this.splitLabel.length;i++) {\n        if(this.splitLabel[i].length > maxLabel.length) {\n          maxLabel = this.splitLabel[i];\n        }\n      }\n\n      var metrics = Q.ctx.measureText(maxLabel);\n      this.p.h = (this.p.size || 24) * this.splitLabel.length * 1.2;\n      this.p.w = metrics.width;\n      this.p.cx = this.p.w / 2;\n      this.p.cy = this.p.h / 2;\n    },\n\n    prerender: function() {\n      if(this.p.oldLabel === this.p.label) { return; }\n      this.p.oldLabel = this.p.label;\n      this.calcSize();\n      this.el.width = this.p.w;\n      this.el.height = this.p.h * 4;\n      this.ctx.clearRect(0,0,this.p.w,this.p.h);\n\n      this.ctx.fillStyle = \"#FF0\";\n      this.ctx.fillRect(0,0,this.p.w,this.p.h/2);\n      this.setFont(this.ctx);\n\n      this.ctx.fillText(this.p.label,0,0);\n    },\n\n    draw: function(ctx) {\n       //this.prerender();\n      if(this.p.opacity === 0) { return; }\n\n      if(this.p.oldLabel !== this.p.label) { this.calcSize(); }\n\n      this.setFont(ctx);\n      if(this.p.opacity !== void 0) { ctx.globalAlpha = this.p.opacity; }\n      for(var i =0;i<this.splitLabel.length;i++) {\n        if(this.p.align === 'center') { \n          ctx.fillText(this.splitLabel[i],0,-this.p.cy + i * this.p.size * 1.2);\n        } else if(this.p.align === 'right') {\n          ctx.fillText(this.splitLabel[i],this.p.cx,-this.p.cy + i * this.p.size * 1.2);\n        } else { \n          ctx.fillText(this.splitLabel[i],-this.p.cx,-this.p.cy +i * this.p.size * 1.2);\n        }\n      }\n    },\n\n    asset: function() {\n      return this.el;\n    },\n\n    setFont: function(ctx) {\n      ctx.textBaseline = \"top\";\n      ctx.font= this.font();\n      ctx.fillStyle = this.p.color || \"black\";\n      ctx.textAlign = this.p.align || \"left\";\n    },\n\n    font: function() {\n      if(this.fontString) { return this.fontString; }\n\n      this.fontString = (this.p.weight || \"800\") + \" \" +\n                        (this.p.size || 24) + \"px \" +\n                        (this.p.family || \"Arial\");\n\n      return this.fontString;\n    }\n\n  });\n\n\n  Q.UI.Button = Q.UI.Container.extend(\"UI.Button\", {\n    init: function(p,callback) {\n      this._super(Q._defaults(p,{\n        type: Q.SPRITE_UI | Q.SPRITE_DEFAULT\n      }));\n      if(this.p.label && (!this.p.w || !this.p.h)) {\n        Q.ctx.save();\n        this.setFont(Q.ctx);\n        var metrics = Q.ctx.measureText(this.p.label);\n        Q.ctx.restore();\n        if(!this.p.h) {  this.p.h = 24 + 20; }\n        if(!this.p.w) { this.p.w = metrics.width + 20; }\n      }\n\n      if(isNaN(this.p.cx)) { this.p.cx = this.p.w / 2; }\n      if(isNaN(this.p.cy)) { this.p.cy = this.p.h / 2; }\n      this.callback = callback;\n      this.on('touch',this,\"highlight\");\n      this.on('touchEnd',this,\"push\");\n    },\n\n    highlight: function() {\n      if(!this.sheet() || this.sheet().frames > 1) {\n        this.p.frame = 1;\n      }\n    },\n\n    push: function() {\n      this.p.frame = 0;\n      if(this.callback) { this.callback(); }\n      this.trigger('click');\n    },\n\n    draw: function(ctx) {\n      this._super(ctx);\n\n      if(this.p.asset || this.p.sheet) {\n        Q.Sprite.prototype.draw.call(this,ctx);\n      }\n\n      if(this.p.label) {\n        ctx.save();\n        this.setFont(ctx);\n        ctx.fillText(this.p.label,0,0);\n        ctx.restore();\n      }\n    },\n\n    setFont: function(ctx) {\n      ctx.textBaseline = \"middle\";\n      ctx.font = this.p.font || \"400 24px arial\";\n      ctx.fillStyle = this.p.fontColor || \"black\";\n      ctx.textAlign = \"center\";\n    }\n\n  });\n\n  Q.UI.IFrame = Q.Sprite.extend(\"UI.IFrame\", {\n    init: function(p) {\n      this._super(p, { opacity: 1, type: Q.SPRITE_UI | Q.SPRITE_DEFAULT });\n\n      Q.wrapper.style.overflow = \"hidden\";\n\n      this.iframe = document.createElement(\"IFRAME\");\n      this.iframe.setAttribute(\"src\",this.p.url);\n      this.iframe.style.position = \"absolute\";\n      this.iframe.style.zIndex = 500;\n      this.iframe.setAttribute(\"width\",this.p.w);\n      this.iframe.setAttribute(\"height\",this.p.h);\n      this.iframe.setAttribute(\"frameborder\",0);\n\n      if(this.p.background) {\n        this.iframe.style.backgroundColor = this.p.background;\n\n      }\n\n\n      Q.wrapper.appendChild(this.iframe);\n      this.on(\"inserted\",function(parent) {\n        this.positionIFrame();\n        parent.on(\"destroyed\",this,\"remove\");\n      });\n    },\n\n    positionIFrame: function() {\n      var x = this.p.x;\n      var y = this.p.y;\n      if(this.stage.viewport) {\n        x -= this.stage.viewport.x;\n        y -= this.stage.viewport.y;\n      }\n\n      if(this.oldX !== x || this.oldY !== y || this.oldOpacity !== this.p.opacity) {\n\n        this.iframe.style.top = (y - this.p.cy) + \"px\";\n        this.iframe.style.left = (x - this.p.cx) + \"px\";\n        this.iframe.style.opacity = this.p.opacity;\n\n        this.oldX = x;\n        this.oldY = y;\n        this.oldOpacity = this.p.opacity;\n      }\n    },\n\n    step: function(dt) {\n      this._super(dt);\n      this.positionIFrame();\n    },\n\n    remove: function() {\n      if(this.iframe) { \n        Q.wrapper.removeChild(this.iframe);\n        this.iframe = null;\n      }\n    }\n  });\n\n  Q.UI.HTMLElement = Q.Sprite.extend(\"UI.HTMLElement\", {\n    init: function(p) {\n      this._super(p, { opacity: 1, type: Q.SPRITE_UI  });\n\n      Q.wrapper.style.overflow = \"hidden\";\n\n      this.el = document.createElement(\"div\");\n      this.el.innerHTML = this.p.html;\n\n      Q.wrapper.appendChild(this.el);\n      this.on(\"inserted\",function(parent) {\n        this.position();\n        parent.on(\"destroyed\",this,\"remove\");\n        parent.on(\"clear\",this,\"remove\");\n      });\n    },\n\n    position: function() {\n    },\n\n    step: function(dt) {\n      this._super(dt);\n      this.position();\n    },\n\n    remove: function() {\n      if(this.el) { \n        Q.wrapper.removeChild(this.el);\n        this.el= null;\n      }\n    }\n  });\n\n  Q.UI.VerticalLayout = Q.Sprite.extend(\"UI.VerticalLayout\",{\n\n\n    init: function(p) {\n      this.children = [];\n      this._super(p, { type: 0 });\n    },\n\n    insert: function(sprite) {\n      this.stage.insert(sprite,this);\n      this.relayout();\n      // Bind to destroy\n      return sprite;\n    },\n\n    relayout: function() {\n      var totalHeight = 0;\n      for(var i=0;i<this.children.length;i++) {\n        totalHeight += this.children[i].p.h || 0;\n      }\n\n      // Center?\n      var totalSepartion = this.p.h - totalHeight;\n\n      // Make sure all elements have the same space between them\n    }\n  });\n\n\n\n};\n\n/*global Quintus:false */\n\nQuintus.Anim = function(Q) {\n\n  Q._animations = {};\n  Q.animations = function(sprite,animations) {\n    if(!Q._animations[sprite]) { Q._animations[sprite] = {}; }\n    Q._extend(Q._animations[sprite],animations);\n  };\n\n  Q.animation = function(sprite,name) {\n    return Q._animations[sprite] && Q._animations[sprite][name];\n  };\n\n  Q.component('animation',{\n    added: function() {\n      var p = this.entity.p;\n      p.animation = null;\n      p.animationPriority = -1;\n      p.animationFrame = 0;\n      p.animationTime = 0;\n      this.entity.on(\"step\",this,\"step\");\n    },\n    extend: {\n      play: function(name,priority) {\n        this.animation.play(name,priority);\n      }\n    },\n    step: function(dt) {\n      var entity = this.entity,\n          p = entity.p;\n      if(p.animation) {\n        var anim = Q.animation(p.sprite,p.animation),\n            rate = anim.rate || p.rate,\n            stepped = 0;\n        p.animationTime += dt;\n        if(p.animationChanged) {\n          p.animationChanged = false;\n        } else { \n          p.animationTime += dt;\n          if(p.animationTime > rate) {\n            stepped = Math.floor(p.animationTime / rate);\n            p.animationTime -= stepped * rate;\n            p.animationFrame += stepped;\n          }\n        }\n        if(stepped > 0) {\n          if(p.animationFrame >= anim.frames.length) {\n            if(anim.loop === false || anim.next) {\n              p.animationFrame = anim.frames.length - 1;\n              entity.trigger('animEnd');\n              entity.trigger('animEnd.' + p.animation);\n              p.animation = null;\n              p.animationPriority = -1;\n              if(anim.trigger) {  \n                entity.trigger(anim.trigger,anim.triggerData);\n              }\n              if(anim.next) { this.play(anim.next,anim.nextPriority); }\n              return;\n            } else {\n              entity.trigger('animLoop');\n              entity.trigger('animLoop.' + p.animation);\n              p.animationFrame = p.animationFrame % anim.frames.length;\n            }\n          }\n          entity.trigger(\"animFrame\");\n        }\n        p.sheet = anim.sheet || p.sheet;\n        p.frame = anim.frames[p.animationFrame];\n      }\n    },\n\n    play: function(name,priority) {\n      var entity = this.entity,\n          p = entity.p;\n      priority = priority || 0;\n      if(name !== p.animation && priority >= p.animationPriority) {\n        p.animation = name;\n        p.animationChanged = true;\n        p.animationTime = 0;\n        p.animationFrame = 0;\n        p.animationPriority = priority;\n        entity.trigger('anim');\n        entity.trigger('anim.' + p.animation);\n      }\n    }\n  \n  });\n\n\n  Q.Sprite.extend(\"Repeater\",{\n    init: function(props) {\n      this._super(Q._defaults(props,{\n        speedX: 1,\n        speedY: 1,\n        repeatY: true,\n        repeatX: true\n      }));\n      this.p.repeatW = this.p.repeatW || this.p.w;\n      this.p.repeatH = this.p.repeatH || this.p.h;\n    },\n\n    draw: function(ctx) {\n      var p = this.p,\n          asset = this.asset(),\n          sheet = this.sheet(),\n          scale = this.stage.viewport ? this.stage.viewport.scale : 1,\n          viewX = this.stage.viewport ? this.stage.viewport.x : 0,\n          viewY = this.stage.viewport ? this.stage.viewport.y : 0,\n          offsetX = p.x + viewX * this.p.speedX,\n          offsetY = p.y + viewY * this.p.speedY,\n          curX, curY, startX;\n      if(p.repeatX) {\n        curX = Math.floor(-offsetX % p.repeatW);\n        if(curX > 0) { curX -= p.repeatW; }\n      } else {\n        curX = p.x - viewX;\n      }\n      if(p.repeatY) {\n        curY = Math.floor(-offsetY % p.repeatH);\n        if(curY > 0) { curY -= p.repeatH; }\n      } else {\n        curY = p.y - viewY;\n      }\n      startX = curX;\n      while(curY < Q.height / scale) {\n        curX = startX;\n        while(curX < Q.width / scale) {\n          if(sheet) {\n            sheet.draw(ctx,Math.floor(curX + viewX), Math.floor(curY + viewY),p.frame);\n          } else {\n            ctx.drawImage(asset,Math.floor(curX + viewX),Math.floor(curY + viewY));\n          }\n          curX += p.repeatW;\n          if(!p.repeatX) { break; }\n        }\n        curY += p.repeatH;\n        if(!p.repeatY) { break; }\n      }\n    }\n  });\n\n  Q.Tween = Q.Class.extend({\n    init: function(entity,properties,duration,easing,options) {\n      if(Q._isObject(easing)) { options = easing; easing = Q.Easing.Linear; }\n      if(Q._isObject(duration)) { options = duration; duration = 1; }\n\n      this.entity = entity;\n      //this.p = (entity instanceof Q.Stage) ? entity.viewport : entity.p;\n      this.duration = duration || 1;\n      this.time = 0;\n      this.options = options || {};\n      this.delay = this.options.delay || 0;\n      this.easing = easing || this.options.easing || Q.Easing.Linear;\n\n      this.startFrame = Q._loopFrame + 1;\n      this.properties = properties;\n      this.start = {};\n      this.diff = {};\n    },\n\n    step: function(dt) {\n      var property;\n\n      if(this.startFrame > Q._loopFrame) { return true; }\n      if(this.delay >= dt) {\n        this.delay -= dt;\n        return true;\n      }\n\n      if(this.delay > 0) {\n        dt -= this.delay;\n        this.delay = 0;\n      }\n\n      if(this.time === 0) {\n        // first time running? Initialize the properties to chaining correctly.\n        var entity = this.entity, properties = this.properties;\n        this.p = (entity instanceof Q.Stage) ? entity.viewport : entity.p;\n        for(property in properties) {\n          this.start[property] = this.p[property];\n          if(!Q._isUndefined(this.start[property])) {\n            this.diff[property] = properties[property] - this.start[property];\n          }\n        }\n      }\n      this.time += dt;\n\n      var progress = Math.min(1,this.time / this.duration),\n          location = this.easing(progress);\n\n      for(property in this.start) {\n        if(!Q._isUndefined(this.p[property])) {\n          this.p[property] = this.start[property] + this.diff[property] * location;\n        }\n      }\n\n      if(progress >= 1) {\n        if(this.options.callback) { \n          this.options.callback.apply(this.entity);\n        }\n      }\n      return progress < 1;\n    }\n  });\n\n  // Code ripped directly from Tween.js\n  // https://github.com/sole/tween.js/blob/master/src/Tween.js\n  Q.Easing = {\n    Linear: function (k) { return k; },\n\n    Quadratic: {\n      In: function ( k )  { return k * k; },\n      Out: function ( k ) {return k * ( 2 - k ); },\n      InOut: function ( k ) {\n        if ((k *= 2 ) < 1) { return 0.5 * k * k; }\n        return -0.5 * (--k * (k - 2) - 1);\n      }\n    }\n  };\n\n  Q.component('tween',{\n    added: function() {\n      this._tweens = [];\n      this.entity.on(\"step\",this,\"step\");\n    },\n    extend: {\n      animate: function(properties,duration,easing,options) {\n        this.tween._tweens.push(new Q.Tween(this,properties,duration,easing,options));\n        return this;\n      },\n\n      chain: function(properties,duration,easing,options) {\n        if(Q._isObject(easing)) { options = easing; easing = Q.Easing.Linear; }\n        // Chain an animation to the end\n        var tweenCnt = this.tween._tweens.length;\n        if(tweenCnt > 0) {\n          var lastTween = this.tween._tweens[tweenCnt - 1];\n          options = options || {};\n          options['delay'] = lastTween.duration - lastTween.time + lastTween.delay;\n        } \n\n        this.animate(properties,duration,easing,options);\n        return this;\n      },\n\n      stop: function() {\n        this.tween._tweens.length = 0;\n        return this;\n      }\n    },\n\n    step: function(dt) {\n      for(var i=0; i < this._tweens.length; i++) {\n        if(!this._tweens[i].step(dt)) {\n          this._tweens.splice(i,1);\n          i--;\n        }\n      }\n    }\n  });\n\n\n};\n\n\n/*global Quintus:false */\n\nQuintus.Input = function(Q) {\n  var KEY_NAMES = { LEFT: 37, RIGHT: 39, SPACE: 32,\n                    UP: 38, DOWN: 40,\n                    Z: 90, X: 88   \n                  };\n  \n  var DEFAULT_KEYS = { LEFT: 'left', RIGHT: 'right',\n                       UP: 'up',     DOWN: 'down',\n                       SPACE: 'fire',\n                       Z: 'fire',\n                       X: 'action' };\n\n  var DEFAULT_TOUCH_CONTROLS  = [ ['left','<' ],\n                            ['right','>' ],\n                            [],\n                            ['action','b'],\n                            ['fire', 'a' ]];\n\n  // Clockwise from midnight (a la CSS)\n  var DEFAULT_JOYPAD_INPUTS =  [ 'up','right','down','left'];\n\n  Q.inputs = {};\n  Q.joypad = {};\n\n  var hasTouch =  !!('ontouchstart' in window);\n\n\n  // Convert a canvas point to a stage point, x dimension\n  Q.canvasToStageX = function(x,stage) {\n    x = x / Q.cssWidth * Q.width;\n    if(stage.viewport) {\n      x /= stage.viewport.scale;\n      x += stage.viewport.x;\n    }\n\n    return x;\n  };\n\n  Q.canvasToStageY = function(y,stage) {\n      y = y / Q.cssWidth * Q.width;\n      if(stage.viewport) {\n        y /= stage.viewport.scale;\n        y += stage.viewport.y;\n      }\n\n      return y;\n  };\n\n\n\n  Q.InputSystem = Q.Evented.extend({\n    keys: {},\n    keypad: {},\n    keyboardEnabled: false,\n    touchEnabled: false,\n    joypadEnabled: false,\n\n    bindKey: function(key,name) {\n      Q.input.keys[KEY_NAMES[key] || key] = name;\n    },\n\n    keyboardControls: function(keys) {\n      keys = keys || DEFAULT_KEYS;\n      Q._each(keys,function(name,key) {\n       this.bindKey(key,name);\n      },Q.input);\n      this.enableKeyboard();\n    },\n\n    enableKeyboard: function() {\n      if(this.keyboardEnabled) { return false; }\n\n      // Make selectable and remove an :focus outline\n      Q.el.tabIndex = 0;\n      Q.el.style.outline = 0;\n\n      Q.el.addEventListener(\"keydown\",function(e) {\n        if(Q.input.keys[e.keyCode]) {\n          var actionName = Q.input.keys[e.keyCode];\n          Q.inputs[actionName] = true;\n          Q.input.trigger(actionName);\n          Q.input.trigger('keydown',e.keyCode);\n        }\n        e.preventDefault();\n      },false);\n\n      Q.el.addEventListener(\"keyup\",function(e) {\n        if(Q.input.keys[e.keyCode]) {\n          var actionName = Q.input.keys[e.keyCode];\n          Q.inputs[actionName] = false;\n          Q.input.trigger(actionName + \"Up\");\n          Q.input.trigger('keyup',e.keyCode);\n        }\n        e.preventDefault();\n      },false);\n      this.keyboardEnabled = true;\n    },\n\n    _containerOffset: function() {\n      Q.input.offsetX = 0;\n      Q.input.offsetY = 0;\n      var el = Q.el;\n      do {\n        Q.input.offsetX += el.offsetLeft;\n        Q.input.offsetY += el.offsetTop;\n      } while(el = el.offsetParent);\n    },\n\n    touchLocation: function(touch) {\n      var el = Q.el, \n        posX = touch.offsetX,\n        posY = touch.offsetY,\n        touchX, touchY;\n\n      if(Q._isUndefined(posX) || Q._isUndefined(posY)) {\n        posX = touch.layerX;\n        posY = touch.layerY;\n      }\n\n      if(Q._isUndefined(posX) || Q._isUndefined(posY)) {\n        if(Q.input.offsetX === void 0) { Q.input._containerOffset(); }\n        posX = touch.pageX - Q.input.offsetX;\n        posY = touch.pageY - Q.input.offsetY;\n      }\n\n      touchX = Q.width * posX / Q.cssWidth;\n      touchY = Q.height * posY / Q.cssHeight;\n\n\n      return { x: touchX, y: touchY };\n    },\n\n    touchControls: function(opts) {\n      if(this.touchEnabled) { return false; }\n      if(!hasTouch) { return false; }\n\n      Q.input.keypad = opts = Q._extend({\n        left: 0,\n        gutter:10,\n        controls: DEFAULT_TOUCH_CONTROLS,\n        width: Q.width,\n        bottom: Q.height\n      },opts);\n\n      opts.unit = (opts.width / opts.controls.length);\n      opts.size = opts.unit - 2 * opts.gutter;\n\n      function getKey(touch) {\n        var pos = Q.input.touchLocation(touch);\n        for(var i=0,len=opts.controls.length;i<len;i++) {\n          if(pos.x < opts.unit * (i+1)) {\n            return opts.controls[i][0];\n          }\n        }\n      }\n\n      function touchDispatch(event) {\n        var wasOn = {},\n            i, len, tch, key, actionName;\n\n        // Reset all the actions bound to controls\n        // but keep track of all the actions that were on\n        for(i=0,len = opts.controls.length;i<len;i++) {\n          actionName = opts.controls[i][0];\n          if(Q.inputs[actionName]) { wasOn[actionName] = true; }\n          Q.inputs[actionName] = false;\n        }\n\n        var touches = event.touches ? event.touches : [ event ];\n\n        for(i=0,len=touches.length;i<len;i++) {\n          tch = touches[i];\n          key = getKey(tch);\n\n          if(key) {\n            // Mark this input as on\n            Q.inputs[key] = true;\n\n            // Either trigger a new action\n            // or remove from wasOn list\n            if(!wasOn[key]) {\n              Q.input.trigger(key);\n            } else {\n              delete wasOn[key];\n            }\n          }\n        }\n\n        // Any remaining were on the last frame\n        // and need to trigger an up action\n        for(actionName in wasOn) {\n          Q.input.trigger(actionName + \"Up\");\n        }\n\n        return null;\n      }\n\n      this.touchDispatchHandler = function(e) {\n        touchDispatch(e);\n        e.preventDefault();\n      };\n\n\n      Q._each([\"touchstart\",\"touchend\",\"touchmove\",\"touchcancel\"],function(evt) {\n        Q.el.addEventListener(evt,this.touchDispatchHandler);\n      },this);\n\n      this.touchEnabled = true;\n    },\n\n    disableTouchControls: function() {\n      Q._each([\"touchstart\",\"touchend\",\"touchmove\",\"touchcancel\"],function(evt) {\n        Q.el.removeEventListener(evt,this.touchDispatchHandler);\n      },this);\n\n      Q.el.removeEventListener('touchstart',this.joypadStart);\n      Q.el.removeEventListener('touchmove',this.joypadMove);\n      Q.el.removeEventListener('touchend',this.joypadEnd);\n      Q.el.removeEventListener('touchcancel',this.joypadEnd);\n      this.touchEnabled = false;\n    },\n\n   joypadControls: function(opts) {\n      if(this.joypadEnabled) { return false; }\n      if(!hasTouch) { return false; }\n\n      var joypad = Q.joypad = Q._defaults(opts || {},{\n        size: 50,\n        trigger: 20,\n        center: 25,\n        color: \"#CCC\",\n        background: \"#000\",\n        alpha: 0.5,\n        zone: Q.width / 2,\n        joypadTouch: null,\n        inputs: DEFAULT_JOYPAD_INPUTS,\n        triggers: []\n      });\n\n      this.joypadStart = function(e) {\n        if(joypad.joypadTouch === null) {\n          var evt = e.originalEvent,\n          touch = evt.changedTouches[0],\n          loc = Q.input.touchLocation(touch);\n\n          if(loc.x < joypad.zone) {\n            joypad.joypadTouch = touch.identifier;\n            joypad.centerX = loc.x;\n            joypad.centerY = loc.y; \n            joypad.x = null;\n            joypad.y = null;\n          }\n        }\n      };\n\n      \n      this.joypadMove = function(e) {\n        if(joypad.joypadTouch !== null) {\n          var evt = e;\n\n          for(var i=0,len=evt.changedTouches.length;i<len;i++) {\n            var touch = evt.changedTouches[i];\n\n            if(touch.identifier === joypad.joypadTouch) {\n              var loc = Q.input.touchLocation(touch),\n                  dx = loc.x - joypad.centerX,\n                  dy = loc.y - joypad.centerY,\n                  dist = Math.sqrt(dx * dx + dy * dy),\n                  overage = Math.max(1,dist / joypad.size),\n                  ang =  Math.atan2(dx,dy);\n\n              if(overage > 1) {\n                dx /= overage;\n                dy /= overage;\n                dist /= overage;\n              }\n\n              var triggers = [\n                dy < -joypad.trigger,\n                dx > joypad.trigger,\n                dy > joypad.trigger,\n                dx < -joypad.trigger\n              ];\n\n              for(var k=0;k<triggers.length;k++) {\n                var actionName = joypad.inputs[k];\n                if(triggers[k]) {\n                  Q.inputs[actionName] = true;\n\n                  if(!joypad.triggers[k]) { \n                    Q.input.trigger(actionName);\n                  }\n                } else {\n                  Q.inputs[actionName] = false;\n                  if(joypad.triggers[k]) { \n                    Q.input.trigger(actionName + \"Up\");\n                  }\n                }\n              }\n\n              Q._extend(joypad, {\n                dx: dx, dy: dy,\n                x: joypad.centerX + dx,\n                y: joypad.centerY + dy,\n                dist: dist,\n                ang: ang,\n                triggers: triggers\n              });\n\n              break;\n            }\n          }\n        }\n        e.preventDefault();\n      };\n\n      this.joypadEnd = function(e) { \n          var evt = e;\n\n          if(joypad.joypadTouch !== null) {\n            for(var i=0,len=evt.changedTouches.length;i<len;i++) { \n            var touch = evt.changedTouches[i];\n              if(touch.identifier === joypad.joypadTouch) {\n                for(var k=0;k<joypad.triggers.length;k++) {\n                  var actionName = joypad.inputs[k];\n                  Q.inputs[actionName] = false;\n                }\n                joypad.joypadTouch = null;\n                break;\n              }\n            }\n          }\n          e.preventDefault();\n      };\n\n\n      Q.el.addEventListener(\"touchstart\",this.joypadStart);\n      Q.el.addEventListener(\"touchmove\",this.joypadMove);\n      Q.el.addEventListener(\"touchend\",this.joypadEnd);\n      Q.el.addEventListener(\"touchcancel\",this.joypadEnd);\n\n      this.joypadEnabled = true;\n    },\n\n    mouseControls: function(options) {\n      options = options || {};\n\n      var stageNum = options.stageNum || 0;\n      var mouseInputX = options.mouseX || \"mouseX\";\n      var mouseInputY = options.mouseY || \"mouseY\";\n\n      var mouseMoveObj = {};\n\n      Q.el.style.cursor = 'none';\n\n      Q.inputs[mouseInputX] = 0;\n      Q.inputs[mouseInputY] = 0;\n\n      Q._mouseMove = function(e) {\n        e.preventDefault();\n        var touch = e.touches ? e.touches[0] : e;\n        var el = Q.el, \n            posX = touch.offsetX,\n            posY = touch.offsetY,\n            eX, eY,\n            stage = Q.stage(stageNum);\n\n        if(Q._isUndefined(posX) || Q._isUndefined(posY)) {\n          posX = touch.layerX;\n          posY = touch.layerY;\n        }\n\n        if(Q._isUndefined(posX) || Q._isUndefined(posY)) {\n          if(Q.input.offsetX === void 0) { Q.input._containerOffset(); }\n          posX = touch.pageX - Q.input.offsetX;\n          posY = touch.pageY - Q.input.offsetY;\n        }\n\n        if(stage) {\n          mouseMoveObj.x= Q.canvasToStageX(posX,stage);\n          mouseMoveObj.y= Q.canvasToStageY(posY,stage);\n\n          Q.inputs[mouseInputX] = mouseMoveObj.x;\n          Q.inputs[mouseInputY] = mouseMoveObj.y;\n\n          Q.input.trigger('mouseMove',mouseMoveObj);\n        }\n      };\n\n      Q.el.addEventListener('mousemove',Q._mouseMove,true);\n      Q.el.addEventListener('touchstart',Q._mouseMove,true);\n      Q.el.addEventListener('touchmove',Q._mouseMove,true);\n    },\n\n    disableMouseControls: function() {\n      if(Q._mouseMove) {\n        Q.el.removeEventListener(\"mousemove\",Q._mouseMove);\n        Q.el.style.cursor = 'inherit';\n        Q._mouseMove = null;\n      }\n    },\n\n    drawButtons: function() {\n      var keypad = Q.input.keypad,\n          ctx = Q.ctx;\n\n      ctx.save();\n      ctx.textAlign = \"center\"; \n      ctx.textBaseline = \"middle\";\n\n      for(var i=0;i<keypad.controls.length;i++) {\n        var control = keypad.controls[i];\n\n        if(control[0]) {\n          ctx.font = \"bold \" + (keypad.size/2) + \"px arial\";\n          var x = i * keypad.unit + keypad.gutter,\n              y = keypad.bottom - keypad.unit,\n              key = Q.inputs[control[0]];\n\n          ctx.fillStyle = keypad.color || \"#FFFFFF\";\n          ctx.globalAlpha = key ? 1.0 : 0.5;\n          ctx.fillRect(x,y,keypad.size,keypad.size);\n\n          ctx.fillStyle = keypad.text || \"#000000\";\n          ctx.fillText(control[1],\n                       x+keypad.size/2,\n                       y+keypad.size/2);\n        }\n      }\n\n      ctx.restore();\n    },\n\n    drawCircle: function(x,y,color,size) {\n      var ctx = Q.ctx,\n          joypad = Q.joypad;\n\n      ctx.save();\n      ctx.beginPath();\n      ctx.globalAlpha=joypad.alpha;\n      ctx.fillStyle = color;\n      ctx.arc(x, y, size, 0, Math.PI*2, true); \n      ctx.closePath();\n      ctx.fill();\n      ctx.restore();\n    },\n\n    drawJoypad: function() {\n      var joypad = Q.joypad;\n      if(joypad.joypadTouch !== null) {\n        Q.input.drawCircle(joypad.centerX,\n                           joypad.centerY,\n                           joypad.background,\n                           joypad.size);\n\n        if(joypad.x !== null) {\n          Q.input.drawCircle(joypad.x,\n                           joypad.y,\n                           joypad.color,\n                           joypad.center);\n        }\n      }\n\n    },\n\n    drawCanvas: function() {\n      if(this.touchEnabled) {\n        this.drawButtons();\n      }\n\n      if(this.joypadEnabled) {\n        this.drawJoypad();\n      }\n    }\n\n\n  });\n  \n  Q.input = new Q.InputSystem();\n\n  Q.controls = function(joypad) {\n    Q.input.keyboardControls();\n\n    if(joypad) {\n      Q.input.touchControls({\n        controls: [ [],[],[],['action','b'],['fire','a']]\n      });\n      Q.input.joypadControls();\n    } else {\n      Q.input.touchControls();\n    }\n\n    return Q;\n  };\n  \n\n  Q.component(\"platformerControls\", {\n    defaults: {\n      speed: 200,\n      jumpSpeed: -300\n    },\n\n    added: function() {\n      var p = this.entity.p;\n\n      Q._defaults(p,this.defaults);\n\n      this.entity.on(\"step\",this,\"step\");\n      this.entity.on(\"bump.bottom\",this,\"landed\");\n\n      p.landed = 0;\n      p.direction ='right';\n    },\n\n    landed: function(col) {\n      var p = this.entity.p;\n      p.landed = 1/5;\n    },\n\n    step: function(dt) {\n      var p = this.entity.p;\n\n      if(Q.inputs['left']) {\n        p.vx = -p.speed;\n        p.direction = 'left';\n      } else if(Q.inputs['right']) {\n        p.direction = 'right';\n        p.vx = p.speed;\n      } else {\n        p.vx = 0;\n      }\n\n      if(p.landed > 0 && (Q.inputs['up'] || Q.inputs['action'])) {\n        p.vy = p.jumpSpeed;\n        p.landed = -dt;\n      }\n      p.landed -= dt;\n\n    }\n  });\n\n\n  Q.component(\"stepControls\", {\n\n    added: function() {\n      var p = this.entity.p;\n\n      if(!p.stepDistance) { p.stepDistance = 32; }\n      if(!p.stepDelay) { p.stepDelay = 0.2; }\n\n      p.stepWait = 0;\n      this.entity.on(\"step\",this,\"step\");\n      this.entity.on(\"hit\", this,\"collision\");\n    },\n\n    collision: function(col) {\n      var p = this.entity.p;\n\n      if(p.stepping) {\n        p.stepping = false;\n        p.x = p.origX;\n        p.y = p.origY;\n      }\n\n    },\n\n    step: function(dt) {\n      var p = this.entity.p,\n          moved = false;\n      p.stepWait -= dt;\n\n      if(p.stepping) {\n        p.x += p.diffX * dt / p.stepDelay;\n        p.y += p.diffY * dt / p.stepDelay;\n      }\n\n      if(p.stepWait > 0) { return; }\n      if(p.stepping) {\n        p.x = p.destX;\n        p.y = p.destY;\n      }\n      p.stepping = false;\n\n      p.diffX = 0;\n      p.diffY = 0;\n\n      if(Q.inputs['left']) {\n        p.diffX = -p.stepDistance;\n      } else if(Q.inputs['right']) {\n        p.diffX = p.stepDistance;\n      }\n\n      if(Q.inputs['up']) {\n        p.diffY = -p.stepDistance;\n      } else if(Q.inputs['down']) {\n        p.diffY = p.stepDistance;\n      }\n\n      if(p.diffY || p.diffX ) { \n        p.stepping = true;\n        p.origX = p.x;\n        p.origY = p.y;\n        p.destX = p.x + p.diffX;\n        p.destY = p.y + p.diffY;\n        p.stepWait = p.stepDelay; \n      }\n\n    }\n\n  });\n};\n\n\n/*global Quintus:false */\n\nQuintus.Touch = function(Q) {\n  if(Q._isUndefined(Quintus.Sprites)) {\n    throw \"Quintus.Touch requires Quintus.Sprites Module\";\n  }\n\n  var hasTouch =  !!('ontouchstart' in window);\n\n  var touchStage = [0];\n  var touchType = 0;\n\n  Q.Evented.extend(\"TouchSystem\",{\n\n    init: function() {\n      var touchSystem = this;\n\n      this.boundTouch = function(e) { touchSystem.touch(e); };\n      this.boundDrag = function(e) { touchSystem.drag(e); };\n      this.boundEnd = function(e) { touchSystem.touchEnd(e); };\n\n      Q.el.addEventListener('touchstart',this.boundTouch);\n      Q.el.addEventListener('mousedown',this.boundTouch);\n\n      Q.el.addEventListener('touchmove',this.boundDrag);\n      Q.el.addEventListener('mousemove',this.boundDrag);\n\n      Q.el.addEventListener('touchend',this.boundEnd);\n      Q.el.addEventListener('mouseup',this.boundEnd);\n      Q.el.addEventListener('touchcancel',this.boundEnd);\n\n      this.touchPos = new Q.Evented();\n      this.touchPos.grid = {};\n      this.touchPos.p = { w:1, h:1, cx: 0, cy: 0 };\n      this.activeTouches = {};\n      this.touchedObjects = {};\n    },\n\n    destroy: function() {\n      Q.el.removeEventListener('touchstart',this.boundTouch);\n      Q.el.removeEventListener('mousedown',this.boundTouch);\n\n      Q.el.removeEventListener('touchmove',this.boundDrag);\n      Q.el.removeEventListener('mousemove',this.boundDrag);\n\n      Q.el.removeEventListener('touchend',this.boundEnd);\n      Q.el.removeEventListener('mouseup',this.boundEnd);\n      Q.el.removeEventListener('touchcancel',this.boundEnd);\n    },\n\n    normalizeTouch: function(touch,stage) {\n      var canvasPosX = touch.offsetX,\n          canvasPosY = touch.offsetY;\n         \n\n      if(Q._isUndefined(canvasPosX) || Q._isUndefined(canvasPosY)) {\n        canvasPosX = touch.layerX;\n        canvasPosY = touch.layerY;\n      }\n\n      if(Q._isUndefined(canvasPosX) || Q._isUndefined(canvasPosY)) {\n        if(Q.touch.offsetX === void 0) {\n          Q.touch.offsetX = 0;\n          Q.touch.offsetY = 0;\n          var el = Q.el;\n          do {\n            Q.touch.offsetX += el.offsetLeft;\n            Q.touch.offsetY += el.offsetTop;\n          } while(el = el.offsetParent);\n        }\n        canvasPosX = touch.pageX - Q.touch.offsetX;\n        canvasPosY = touch.pageY - Q.touch.offsetY;\n      }\n\n\n      this.touchPos.p.ox = this.touchPos.p.px = canvasPosX / Q.cssWidth * Q.width;\n      this.touchPos.p.oy = this.touchPos.p.py = canvasPosY / Q.cssHeight * Q.height;\n      \n      if(stage.viewport) {\n        this.touchPos.p.px /= stage.viewport.scale;\n        this.touchPos.p.py /= stage.viewport.scale;\n        this.touchPos.p.px += stage.viewport.x;\n        this.touchPos.p.py += stage.viewport.y;\n      }\n\n      this.touchPos.p.x = this.touchPos.p.px;\n      this.touchPos.p.y = this.touchPos.p.py;\n\n      this.touchPos.obj = null;\n      return this.touchPos;\n    },\n\n    touch: function(e) {\n      var touches = e.changedTouches || [ e ];\n\n      for(var i=0;i<touches.length;i++) {\n\n        for(var stageIdx=0;stageIdx < touchStage.length;stageIdx++) {\n          var touch = touches[i],\n              stage = Q.stage(touchStage[stageIdx]);\n\n          if(!stage) { continue; }\n\n          touch.identifier = touch.identifier || 0;\n          var pos = this.normalizeTouch(touch,stage);\n\n          stage.regrid(pos,true);\n          var col = stage.search(pos,touchType), obj;\n\n          if(col || stageIdx === touchStage.length - 1) {\n            obj = col && col.obj;\n            pos.obj = obj;\n            this.trigger(\"touch\",pos);\n          }\n\n          if(obj && !this.touchedObjects[obj]) {\n            this.activeTouches[touch.identifier] = {\n              x: pos.p.px,\n              y: pos.p.py,\n              origX: obj.p.x,\n              origY: obj.p.y,\n              sx: pos.p.ox,\n              sy: pos.p.oy,\n              identifier: touch.identifier,\n              obj: obj,\n              stage: stage\n            };\n            this.touchedObjects[obj.p.id] = true;\n            obj.trigger('touch', this.activeTouches[touch.identifier]);\n            break;\n          }\n\n        }\n\n      }\n      //e.preventDefault();\n    },\n\n    drag: function(e) {\n      var touches = e.changedTouches || [ e ];\n\n      for(var i=0;i<touches.length;i++) {\n        var touch = touches[i];\n        touch.identifier = touch.identifier || 0;\n\n        var active = this.activeTouches[touch.identifier],\n            stage = active && active.stage;\n\n        if(active) {\n          var pos = this.normalizeTouch(touch,stage);\n          active.x = pos.p.px;\n          active.y = pos.p.py;\n          active.dx = pos.p.ox - active.sx;\n          active.dy = pos.p.oy - active.sy;\n\n          active.obj.trigger('drag', active);\n        }\n      }\n      e.preventDefault();\n    },\n\n    touchEnd: function(e) {\n      var touches = e.changedTouches || [ e ];\n\n      for(var i=0;i<touches.length;i++) {\n        var touch = touches[i];\n\n        touch.identifier = touch.identifier || 0;\n\n        var active = this.activeTouches[touch.identifier];\n\n        if(active) {\n          active.obj.trigger('touchEnd', active);\n          delete this.touchedObjects[active.obj.p.id];\n          this.activeTouches[touch.identifier] = null;\n        }\n      }\n      e.preventDefault();\n    }\n\n  });\n\n  Q.touch = function(type,stage) {\n    Q.untouch();\n    touchType = type || Q.SPRITE_UI;\n    touchStage = stage || [2,1,0];\n    if(!Q._isArray(touchStage)) {\n      touchStage = [touchStage];\n    }\n\n    if(!Q._touch) {\n      Q.touchInput = new Q.TouchSystem();\n    }\n    return Q;\n  };\n\n  Q.untouch = function() {\n    if(Q.touchInput) {\n      Q.touchInput.destroy();\n      delete Q['touchInput'];\n    }\n    return Q;\n  };\n\n};\n\n/*global Quintus:false */\n\nQuintus.Sprites = function(Q) {\n \n  // Create a new sprite sheet\n  // Options:\n  //  tilew - tile width\n  //  tileh - tile height\n  //  w     - width of the sprite block\n  //  h     - height of the sprite block\n  //  sx    - start x\n  //  sy    - start y\n  //  cols  - number of columns per row\n  Q.Class.extend(\"SpriteSheet\",{\n    init: function(name, asset,options) {\n      if(!Q.asset(asset)) { throw \"Invalid Asset:\" + asset; }\n      Q._extend(this,{\n        name: name,\n        asset: asset,\n        w: Q.asset(asset).width,\n        h: Q.asset(asset).height,\n        tilew: 64,\n        tileh: 64,\n        sx: 0,\n        sy: 0\n        });\n      if(options) { Q._extend(this,options); }\n      this.cols = this.cols || \n                  Math.floor(this.w / this.tilew);\n    },\n\n    fx: function(frame) {\n      return Math.floor((frame % this.cols) * this.tilew + this.sx);\n    },\n\n    fy: function(frame) {\n      return Math.floor(Math.floor(frame / this.cols) * this.tileh + this.sy);\n    },\n\n    draw: function(ctx, x, y, frame) {\n      if(!ctx) { ctx = Q.ctx; }\n      ctx.drawImage(Q.asset(this.asset),\n                    this.fx(frame),this.fy(frame),\n                    this.tilew, this.tileh,\n                    Math.floor(x),Math.floor(y),\n                    this.tilew, this.tileh);\n\n    }\n\n  });\n\n\n  Q.sheets = {};\n  Q.sheet = function(name,asset,options) {\n    if(asset) {\n      Q.sheets[name] = new Q.SpriteSheet(name,asset,options);\n    } else {\n      return Q.sheets[name];\n    }\n  };\n\n  Q.compileSheets = function(imageAsset,spriteDataAsset) {\n    var data = Q.asset(spriteDataAsset);\n    Q._each(data,function(spriteData,name) {\n      Q.sheet(name,imageAsset,spriteData);\n    });\n  };\n\n\n  Q.SPRITE_NONE     = 0;\n  Q.SPRITE_DEFAULT  = 1;\n  Q.SPRITE_PARTICLE = 2;\n  Q.SPRITE_ACTIVE   = 4;\n  Q.SPRITE_FRIENDLY = 8;\n  Q.SPRITE_ENEMY    = 16;\n  Q.SPRITE_POWERUP  = 32;\n  Q.SPRITE_UI       = 64;\n  Q.SPRITE_ALL   = 0xFFFF;\n\n\n  Q._generatePoints = function(obj,force) {\n    if(obj.p.points && !force) { return; }\n    var p = obj.p,\n        halfW = p.w/2,\n        halfH = p.h/2;\n\n    p.points = [ \n      [ -halfW, -halfH ],\n      [  halfW, -halfH ],\n      [  halfW,  halfH ],\n      [ -halfW,  halfH ]\n      ];\n  };\n\n Q._generateCollisionPoints = function(obj) {\n    if(!obj.matrix && !obj.refreshMatrix) { return; }\n    if(!obj.c) { obj.c = { points: [] }; }\n    var p = obj.p, c = obj.c;\n\n    if(!p.moved && \n       c.origX === p.x &&\n       c.origY === p.y &&\n       c.origScale === p.scale &&\n       c.origScale === p.angle) { \n        return;\n    }\n\n    c.origX = p.x;\n    c.origY = p.y;\n    c.origScale = p.scale;\n    c.origAngle = p.angle;\n\n    obj.refreshMatrix();\n\n    var container = obj.container || Q._nullContainer;\n\n    // TODO: see if we care or if it's more \n    // efficient just to do the calc each time\n    c.x = container.matrix.transformX(p.x,p.y);\n    c.y = container.matrix.transformY(p.x,p.y);\n    c.angle = p.angle + container.c.angle;\n    c.scale = (container.c.scale || 1) * (p.scale || 1);\n\n    var minX = Infinity,\n        minY = Infinity,\n        maxX = -Infinity,\n        maxY = -Infinity;\n\n    for(var i=0;i<obj.p.points.length;i++) {\n      if(!obj.c.points[i]) {\n        obj.c.points[i] = [];\n      }\n      obj.matrix.transformArr(obj.p.points[i],obj.c.points[i]);\n      var x = obj.c.points[i][0],\n          y = obj.c.points[i][1];\n\n          if(x < minX) { minX = x; }\n          if(x > maxX) { maxX = x; }\n          if(y < minY) { minY = y; }\n          if(y > maxY) { maxY = y; }\n    }\n\n    if(minX === maxX) { maxX+=1; }\n    if(minY === maxY) { maxY+=1; }\n\n    c.cx = c.x - minX;\n    c.cy = c.y - minY;\n\n    c.w = maxX - minX;\n    c.h = maxY - minY;\n\n    // TODO: Invoke moved on children\n  };\n  \n  \n  \n// Properties:\n  //    x\n  //    y\n  //    z - sort order\n  //    sheet or asset\n  //    frame\n  Q.GameObject.extend(\"Sprite\",{\n    init: function(props,defaultProps) {\n      this.p = Q._extend({ \n        x: 0,\n        y: 0,\n        z: 0,\n        angle: 0,\n        frame: 0,\n        type: Q.SPRITE_DEFAULT | Q.SPRITE_ACTIVE\n      },defaultProps);\n\n      this.matrix = new Q.Matrix2D();\n      this.children = [];\n\n      Q._extend(this.p,props); \n\n      this.size();\n      this.p.id = this.p.id || Q._uniqueId();\n\n      this.c = { points: [] };\n\n      this.refreshMatrix();\n    },\n\n    // Resets the width, height and center based on the\n    // asset or sprite sheet\n    size: function(force) {\n      if(force || (!this.p.w || !this.p.h)) { \n        if(this.asset()) {\n          this.p.w = this.asset().width;\n          this.p.h = this.asset().height;\n        } else if(this.sheet()) {\n          this.p.w = this.sheet().tilew;\n          this.p.h = this.sheet().tileh;\n        }\n      } \n\n      this.p.cx = (force || this.p.cx === void 0) ? (this.p.w / 2) : this.p.cx;\n      this.p.cy = (force || this.p.cy === void 0) ? (this.p.h / 2) : this.p.cy;\n    },\n\n    // Get or set the asset associate with this sprite\n    asset: function(name,resize) {\n      if(!name) { return Q.asset(this.p.asset); }\n\n      this.p.asset = name;\n      if(resize) {\n        this.size(true);\n        Q._generatePoints(this,true);\n      }\n    },\n\n    // Get or set the sheet associate with this sprite\n    sheet: function(name,resize) {\n      if(!name) { return Q.sheet(this.p.sheet); }\n\n      this.p.sheet = name;\n      if(resize) { \n        this.size(true);\n        Q._generatePoints(this,true);\n      }\n    },\n\n    hide: function() {\n      this.p.hidden = true;\n    },\n\n    show: function() {\n      this.p.hidden = false;\n    },\n\n    set: function(properties) {\n      Q._extend(this.p,properties);\n      return this;\n    },\n\n    render: function(ctx) {\n      var p = this.p;\n\n      if(p.hidden) { return; }\n      if(!ctx) { ctx = Q.ctx; }\n\n      this.trigger('predraw',ctx);\n\n      ctx.save();\n\n        if(this.p.opacity !== void 0 && this.p.opacity !== 1) {\n          ctx.globalAlpha = this.p.opacity;\n        }\n\n        this.matrix.setContextTransform(ctx);\n\n        this.trigger('beforedraw',ctx);\n        this.draw(ctx);\n        this.trigger('draw',ctx);\n\n      ctx.restore();\n      \n      // Children set up their own complete matrix\n      // from the base stage matrix\n      Q._invoke(this.children,\"render\",ctx);\n      \n      this.trigger('postdraw',ctx);\n\n      if(Q.debug) { this.debugRender(ctx); }\n\n    },\n\n    center: function() {\n      if(this.container) {\n        this.p.x = this.container.p.w / 2;\n        this.p.y = this.container.p.h / 2;\n      } else {\n        this.p.x = Q.width / 2;\n        this.p.y = Q.height / 2;\n      }\n\n    },\n\n    draw: function(ctx) {\n      var p = this.p;\n      if(p.sheet) {\n        this.sheet().draw(ctx,-p.cx,-p.cy,p.frame);\n      } else if(p.asset) {\n        ctx.drawImage(Q.asset(p.asset),-p.cx,-p.cy);\n      }\n    },\n\n    debugRender: function(ctx) {\n      if(!this.p.points) {\n        Q._generatePoints(this);\n      }\n      ctx.save();\n      this.matrix.setContextTransform(ctx);\n      ctx.beginPath();\n      ctx.fillStyle = this.p.hit ? \"blue\" : \"red\";\n      ctx.strokeStyle = \"#FF0000\";\n      ctx.fillStyle = \"rgba(0,0,0,0.5)\";\n\n      ctx.moveTo(this.p.points[0][0],this.p.points[0][1]);\n      for(var i=0;i<this.p.points.length;i++) {\n        ctx.lineTo(this.p.points[i][0],this.p.points[i][1]);\n      }\n      ctx.lineTo(this.p.points[0][0],this.p.points[0][1]);\n      ctx.stroke();\n      if(Q.debugFill) { ctx.fill(); }\n\n      ctx.restore();\n\n      if(this.c) { \n        var c = this.c;\n        ctx.save();\n          ctx.globalAlpha = 1;\n          ctx.lineWidth = 2;\n          ctx.strokeStyle = \"#FF00FF\";\n          ctx.beginPath();\n          ctx.moveTo(c.x - c.cx,       c.y - c.cy);\n          ctx.lineTo(c.x - c.cx + c.w, c.y - c.cy);\n          ctx.lineTo(c.x - c.cx + c.w, c.y - c.cy + c.h);\n          ctx.lineTo(c.x - c.cx      , c.y - c.cy + c.h);\n          ctx.lineTo(c.x - c.cx,       c.y - c.cy);\n          ctx.stroke();\n        ctx.restore();\n      }\n    },\n\n    update: function(dt) {\n      this.trigger('prestep',dt);\n      if(this.step) { this.step(dt); }\n      this.trigger('step',dt);\n      this.refreshMatrix();\n\n      // Ugly coupling to stage - workaround?\n      if(this.stage && this.children.length > 0) {\n        this.stage.updateSprites(this.children,dt,true);\n      }\n    },\n\n    refreshMatrix: function() {\n      var p = this.p;\n      this.matrix.identity();\n\n      if(this.container) { this.matrix.multiply(this.container.matrix); }\n      \n      this.matrix.translate(p.x,p.y);\n\n      if(p.scale) { this.matrix.scale(p.scale,p.scale); }\n\n      this.matrix.rotateDeg(p.angle);\n    }\n  });\n\n  Q.Sprite.extend(\"MovingSprite\",{\n    init: function(props,defaultProps) {\n      this._super(Q._extend({\n        vx: 0,\n        vy: 0,\n        ax: 0,\n        ay: 0\n      },props),defaultProps);\n   },\n\n   step: function(dt) {\n     var p = this.p;\n\n     p.vx += p.ax * dt;\n     p.vy += p.ay * dt;\n\n     p.x += p.vx * dt;\n     p.y += p.vy * dt;\n   }\n });\n\n\n\n\n  return Q;\n};\n\n\n/*global Quintus:false */\n\nQuintus.Scenes = function(Q) {\n\n  Q.scenes = {};\n  Q.stages = [];\n\n  Q.Scene = Q.Class.extend({\n    init: function(sceneFunc,opts) {\n      this.opts = opts || {};\n      this.sceneFunc = sceneFunc;\n    }\n  });\n\n  // Set up or return a new scene\n  Q.scene = function(name,sceneObj,opts) {\n    if(sceneObj === void 0) {\n      return Q.scenes[name];\n    } else {\n      if(Q._isFunction(sceneObj)) {\n        sceneObj = new Q.Scene(sceneObj,opts);\n      }\n      Q.scenes[name] = sceneObj;\n      return sceneObj;\n    }\n  };\n\n  Q._nullContainer = {\n    c: {\n      x: 0,\n      y: 0,\n      cx: 0,\n      cy: 0,\n      angle: 0,\n      scale: 1\n    },\n    matrix: Q.matrix2d()\n  };\n\n \n  // Default to SAT collision between two objects\n  // Thanks to doc's at: http://www.sevenson.com.au/actionscript/sat/\n  // TODO: handle angles on objects \n  Q.collision = (function() { \n    var normalX, normalY,\n        offset = [ 0,0 ],\n        result1 = { separate: [] },\n        result2 = { separate: [] };\n\n    function calculateNormal(points,idx) {\n      var pt1 = points[idx],\n          pt2 = points[idx+1] || points[0];\n\n      normalX = -(pt2[1] - pt1[1]);\n      normalY = pt2[0] - pt1[0];\n\n      var dist = Math.sqrt(normalX*normalX + normalY*normalY);\n      if(dist > 0) {\n        normalX /= dist;\n        normalY /= dist;\n      }\n    }\n\n    function dotProductAgainstNormal(point) {\n      return (normalX * point[0]) + (normalY * point[1]);\n\n    }\n\n    function collide(o1,o2,flip) {\n      var min1,max1,\n          min2,max2,\n          d1, d2,\n          offsetLength,\n          tmp, i, j,\n          minDist, minDistAbs,\n          shortestDist = Number.POSITIVE_INFINITY,\n          collided = false,\n          p1, p2;\n\n      var result = flip ? result2 : result1;\n\n      offset[0] = 0; //o1.x + o1.cx - o2.x - o2.cx;\n      offset[1] = 0; //o1.y + o1.cy - o2.y - o2.cy;\n\n      // If we have a position matrix, just use those points,\n      if(o1.c) {\n        p1 = o1.c.points;\n      } else {\n        p1 = o1.p.points;\n        offset[0] += o1.p.x;\n        offset[1] += o1.p.y;\n      }\n\n      if(o2.c) {\n        p2 = o2.c.points;\n      } else {\n        p2 = o2.p.points;\n        offset[0] += -o2.p.x;\n        offset[1] += -o2.p.y; \n      }\n\n      o1 = o1.p;\n      o2 = o2.p;\n\n\n      for(i = 0;i<p1.length;i++) {\n        calculateNormal(p1,i);\n\n        min1 = dotProductAgainstNormal(p1[0]);\n        max1 = min1;\n\n        for(j = 1; j<p1.length;j++) {\n          tmp = dotProductAgainstNormal(p1[j]);\n          if(tmp < min1) { min1 = tmp; }\n          if(tmp > max1) { max1 = tmp; }\n        }\n\n        min2 = dotProductAgainstNormal(p2[0]);\n        max2 = min2;\n\n        for(j = 1;j<p2.length;j++) {\n          tmp = dotProductAgainstNormal(p2[j]);\n          if(tmp < min2) { min2 = tmp; }\n          if(tmp > max2) { max2 = tmp; }\n        }\n\n        offsetLength = dotProductAgainstNormal(offset);\n        min1 += offsetLength;\n        max1 += offsetLength;\n\n        d1 = min1 - max2;\n        d2 = min2 - max1;\n\n        if(d1 > 0 || d2 > 0) { return null; }\n\n        minDist = (max2 - min1) * -1;\n        if(flip) { minDist *= -1; }\n\n        minDistAbs = Math.abs(minDist);\n\n        if(minDistAbs < shortestDist) {\n          result.distance = minDist;\n          result.magnitude = minDistAbs;\n          result.normalX = normalX;\n          result.normalY = normalY;\n\n          if(result.distance > 0) {\n            result.distance *= -1;\n            result.normalX *= -1;\n            result.normalY *= -1;\n          }\n\n          collided = true;\n          shortestDist = minDistAbs;\n        }\n      }\n\n      // Do return the actual collision\n      return collided ? result : null;\n    }\n\n    function satCollision(o1,o2) {\n      var result1, result2, result;\n\n      // Don't compare a square to a square for no reason\n      // if(!o1.p.points && !o2.p.points) return true;\n\n      if(!o1.p.points) { Q._generatePoints(o1); }\n      if(!o2.p.points) { Q._generatePoints(o2); }\n\n      Q._generateCollisionPoints(o1);\n      Q._generateCollisionPoints(o2);\n\n      result1 = collide(o1,o2);\n      if(!result1) { return false; }\n\n      result2 = collide(o2,o1,true);\n      if(!result2) { return false; }\n\n      result = (result2.magnitude < result1.magnitude) ? result2 : result1;\n\n      if(result.magnitude === 0) { return false; }\n      result.separate[0] = result.distance * result.normalX;\n      result.separate[1] = result.distance * result.normalY;\n\n      return result;\n    }\n\n    return satCollision;\n  }());\n\n\n  Q.overlap = function(o1,o2) {\n    var c1 = o1.c || o1.p;\n    var c2 = o2.c || o2.p;\n\n    var o1x = c1.x - c1.cx,\n        o1y = c1.y - c1.cy;\n    var o2x = c2.x - c2.cx,\n        o2y = c2.y - c2.cy;\n\n    return !((o1y+c1.h<o2y) || (o1y>o2y+c2.h) ||\n             (o1x+c1.w<o2x) || (o1x>o2x+c2.w));\n  };\n\n  Q.Stage = Q.GameObject.extend({\n    // Should know whether or not the stage is paused\n    defaults: {\n      sort: false,\n      gridW: 400,\n      gridH: 400\n    },\n\n    init: function(scene,opts) {\n      this.scene = scene;\n      this.items = [];\n      this.lists = {};\n      this.index = {};\n      this.removeList = [];\n      this.grid = {};\n\n      this.options = Q._extend({},this.defaults);\n      if(this.scene)  { \n        Q._extend(this.options,scene.opts);\n      }\n      if(opts) { Q._extend(this.options,opts); }\n\n\n      if(this.options.sort && !Q._isFunction(this.options.sort)) {\n          this.options.sort = function(a,b) { return ((a.p && a.p.z) || -1) - ((b.p && b.p.z) || -1); };\n      }\n    },\n\n    destroyed: function() {\n      this.invoke(\"debind\");\n      this.trigger(\"destroyed\");\n    },\n\n    // Needs to be separated out so the current stage can be set\n    loadScene: function() {\n      if(this.scene)  { \n        this.scene.sceneFunc(this);\n      }\n    },\n\n    each: function(callback) {\n      for(var i=0,len=this.items.length;i<len;i++) {\n        callback.call(this.items[i],arguments[1],arguments[2]);\n      }\n    },\n\n    invoke: function(funcName) {\n      for(var i=0,len=this.items.length;i<len;i++) {              \n        this.items[i][funcName].call(\n          this.items[i],arguments[1],arguments[2]\n        );\n      }\n    },\n\n    detect: function(func) {\n      for(var i = this.items.length-1;i >= 0; i--) {\n        if(func.call(this.items[i],arguments[1],arguments[2],arguments[3])) {\n          return this.items[i];\n        }\n      }\n      return false;\n    },\n\n\n    identify: function(func) {\n      var result;\n      for(var i = this.items.length-1;i >= 0; i--) {\n        if(result = func.call(this.items[i],arguments[1],arguments[2],arguments[3])) {\n          return result;\n        }\n      }\n      return false;\n    },\n\n    addToLists: function(lists,object) {\n      for(var i=0;i<lists.length;i++) {\n        this.addToList(lists[i],object);\n      }\n    },\n\n    addToList: function(list, itm) {\n      if(!this.lists[list]) { this.lists[list] = []; }\n      this.lists[list].push(itm);\n    },\n\n\n    removeFromLists: function(lists, itm) {\n      for(var i=0;i<lists.length;i++) {\n        this.removeFromList(lists[i],itm);\n      }\n    },\n\n    removeFromList: function(list, itm) {\n      var listIndex = this.lists[list].indexOf(itm);\n      if(listIndex !== -1) { \n        this.lists[list].splice(listIndex,1);\n      }\n    },\n\n    insert: function(itm,container) {\n      this.items.push(itm);\n      itm.stage = this;\n      itm.container = container;\n      if(container) {\n        container.children.push(itm);\n      }\n\n      itm.grid = {};\n\n\n      // Make sure we have a square of collision points\n      Q._generatePoints(itm);\n      Q._generateCollisionPoints(itm);\n\n      \n      if(itm.className) { this.addToList(itm.className, itm); }\n      if(itm.activeComponents) { this.addToLists(itm.activeComponents, itm); }\n\n      if(itm.p) {\n        this.index[itm.p.id] = itm;\n      }\n      this.trigger('inserted',itm);\n      itm.trigger('inserted',this);\n\n      this.regrid(itm);\n      return itm;\n    },\n\n    remove: function(itm) {\n      this.delGrid(itm);\n      this.removeList.push(itm);\n    },\n\n    forceRemove: function(itm) {\n      var idx =  this.items.indexOf(itm);\n      if(idx !== -1) { \n        this.items.splice(idx,1);\n\n        if(itm.className) { this.removeFromList(itm.className,itm); }\n        if(itm.activeComponents) { this.removeFromLists(itm.activeComponents,itm); }\n        if(itm.container) {\n          var containerIdx = itm.container.children.indexOf(itm);\n          if(containerIdx !== -1) {\n            itm.container.children.splice(containerIdx,1);\n          }\n        }\n\n        if(itm.destroy) { itm.destroy(); }\n        if(itm.p.id) {\n          delete this.index[itm.p.id];\n        }\n        this.trigger('removed',itm);\n      }\n    },\n\n    pause: function() {\n      this.paused = true;\n    },\n\n    unpause: function() {\n      this.paused = false;\n    },\n\n    _gridCellCheck: function(type,id,obj,collisionMask) {\n      if(!collisionMask || collisionMask & type) {\n        var obj2 = this.index[id];\n        if(obj2 && obj2 !== obj && Q.overlap(obj,obj2)) {\n          var col= Q.collision(obj,obj2);\n          if(col) {\n            col.obj = obj2;\n            return col;\n          } else {\n            return false;\n          }\n        }\n      }\n    },\n\n    gridTest: function(obj,collisionMask,collisionLayer) {\n      var grid = obj.grid, gridCell, col;\n\n      for(var y = grid.Y1;y <= grid.Y2;y++) {\n        if(this.grid[y]) {\n          for(var x = grid.X1;x <= grid.X2;x++) {\n            gridCell = this.grid[y][x];\n            if(gridCell) { \n              col = Q._detect(gridCell,this._gridCellCheck,this,obj,collisionMask);\n              if(col) { return col; }\n            }\n          }\n        }\n      }\n      return false;\n    },\n\n    collisionLayer: function(layer) {\n      this._collisionLayer = layer;\n      this.insert(layer);\n    },\n\n    search: function(obj,collisionMask) {\n      var col;\n\n      collisionMask = collisionMask || (obj.p && obj.p.collisionMask);\n      if(this._collisionLayer && (this._collisionLayer.p.type & collisionMask)) {\n        col = this._collisionLayer.collide(obj);\n        if(col) { return col; }\n      }\n\n      col = this.gridTest(obj,collisionMask,this._collisionLayer);\n      return col;\n    },\n\n    _locateObj: {\n      p: { \n        x: 0,\n        y: 0,\n        w: 1,\n        h: 1\n      }, grid: {}\n    },\n\n    locate: function(x,y,collisionMask) {\n      var col = null;\n\n      this._locateObj.p.x = x;\n      this._locateObj.p.y = y;\n\n      this.regrid(this._locateObj,true);\n\n      if(this._collisionLayer && (this._collisionLayer.p.type & collisionMask)) {\n        col = this._collisionLayer.collide(this._locateObj);\n      }\n\n      if(!col) { \n        col = this.gridTest(this._locateObj,collisionMask,this._collisionLayer);\n      }\n\n      if(col && col.obj) {\n        return col.obj;\n      } else {\n        return false;\n      }\n\n    },\n\n    collide: function(obj,collisionMask) {\n      var col, col2, maxCol = 3;\n      collisionMask = collisionMask || (obj.p && obj.p.collisionMask);\n      this.regrid(obj);\n      if(this._collisionLayer && (this._collisionLayer.p.type & collisionMask)) {\n        while(maxCol > 0 && (col = this._collisionLayer.collide(obj))) {\n          col.obj = this._collisionLayer;\n          obj.trigger('hit',col);\n          obj.trigger('hit.collision',col);\n          this.regrid(obj);\n          maxCol--;\n        }\n      }\n\n      col2 = this.gridTest(obj,collisionMask,this._collisionLayer);\n      if(col2) {\n        obj.trigger('hit',col2);\n        obj.trigger('hit.sprite',col2);\n\n        // Do the recipricol collision\n        // TODO: extract\n        var obj2 = col2.obj;\n        col2.obj = obj;\n        col2.normalX *= -1;\n        col2.normalY *= -1;\n        col2.distance = 0;\n        col2.magnitude = 0;\n        col2.separate[0] = 0;\n        col2.separate[1] = 0;\n\n        obj2.trigger('hit',col2);\n        obj2.trigger('hit.sprite',col2);\n\n        this.regrid(obj);\n      }\n\n      return col2 || col;\n    },\n\n    delGrid: function(item) {\n      var grid = item.grid;\n\n      for(var y = grid.Y1;y <= grid.Y2;y++) {\n        if(this.grid[y]) {\n          for(var x = grid.X1;x <= grid.X2;x++) {\n            if(this.grid[y][x]) {\n            delete this.grid[y][x][item.p.id];\n            }\n          }\n        }\n      }\n    },\n\n    addGrid: function(item) {\n      var grid = item.grid;\n\n      for(var y = grid.Y1;y <= grid.Y2;y++) {\n        if(!this.grid[y]) { this.grid[y] = {}; }\n        for(var x = grid.X1;x <= grid.X2;x++) {\n          if(!this.grid[y][x]) { this.grid[y][x] = {}; }\n          this.grid[y][x][item.p.id] = item.p.type;\n        }\n      }\n\n    },\n\n    // Add an item into the collision detection grid,\n    // Ignore the collision layer or objects without a type\n    regrid: function(item,skipAdd) {\n      if(this._collisionLayer && item === this._collisionLayer) { return; }\n      if(!item.p.type && !skipAdd) { return; }\n\n      var c = item.c || item.p;\n\n      var gridX1 = Math.floor(c.x / this.options.gridW),\n          gridY1 = Math.floor(c.y / this.options.gridH),\n          gridX2 = Math.floor((c.x + c.w) / this.options.gridW),\n          gridY2 = Math.floor((c.y + c.h) / this.options.gridH),\n          grid = item.grid;\n\n      if(grid.X1 !== gridX1 || grid.X2 !== gridX2 || \n         grid.Y1 !== gridY1 || grid.Y2 !== gridY2) {\n\n         if(grid.X1 !== void 0) { this.delGrid(item); }\n         grid.X1 = gridX1;\n         grid.X2 = gridX2;\n         grid.Y1 = gridY1;\n         grid.Y2 = gridY2;\n\n         if(!skipAdd) { this.addGrid(item); }\n      }\n    },\n\n    updateSprites: function(items,dt,isContainer) {\n      var item;\n\n      for(var i=0,len=items.length;i<len;i++) {              \n        item = items[i];\n        if(isContainer || !item.container) { \n          item.update(dt);\n          Q._generateCollisionPoints(item);\n          this.regrid(item);\n        }\n      }\n    },\n\n\n\n    step:function(dt) {\n      if(this.paused) { return false; }\n\n      this.trigger(\"prestep\",dt);\n      this.updateSprites(this.items,dt);\n      this.trigger(\"step\",dt);\n\n      if(this.removeList.length > 0) {\n        for(var i=0,len=this.removeList.length;i<len;i++) {\n          this.forceRemove(this.removeList[i]);\n        }\n        this.removeList.length = 0;\n      }\n\n      this.trigger('poststep',dt);\n    },\n\n    render: function(ctx) {\n      if(this.options.sort) {\n        this.items.sort(this.options.sort);\n      }\n      this.trigger(\"prerender\",ctx);\n      this.trigger(\"beforerender\",ctx);\n\n      for(var i=0,len=this.items.length;i<len;i++) {              \n        var item = this.items[i];\n        // Don't render sprites with containers (sprites do that themselves)\n        if(!item.container) { \n          item.render(ctx);\n        }\n      }\n      this.trigger(\"render\",ctx);\n      this.trigger(\"postrender\",ctx);\n    }\n  });\n\n  Q.activeStage = 0;\n\n  Q.StageSelector = Q.Class.extend({\n    emptyList: [],\n\n    init: function(stage,selector) {\n      this.stage = stage;\n      this.selector = selector;\n\n      // Generate an object list from the selector\n      // TODO: handle array selectors\n      this.items = this.stage.lists[this.selector] || this.emptyList;\n      this.length = this.items.length;\n    },\n\n    each: function(callback) {\n      for(var i=0,len=this.items.length;i<len;i++) {\n        callback.call(this.items[i],arguments[1],arguments[2]);\n      }\n      return this;\n    },\n\n    invoke: function(funcName) {\n      for(var i=0,len=this.items.length;i<len;i++) {              \n        this.items[i][funcName].call(\n          this.items[i],arguments[1],arguments[2]\n        );\n      }\n      return this;\n    },\n\n    trigger: function(name,params) {\n      this.invoke(\"trigger\",name,params);\n    },\n\n    destroy: function() {\n      this.invoke(\"destroy\");\n    },\n\n    detect: function(func) {\n      for(var i = 0,val=null, len=this.items.length; i < len; i++) {\n        if(func.call(this.items[i],arguments[1],arguments[2])) {\n          return this.items[i];\n        }\n      }\n      return false;\n    },\n\n    identify: function(func) {\n      var result = null;\n      for(var i = 0,val=null, len=this.items.length; i < len; i++) {\n        if(result = func.call(this.items[i],arguments[1],arguments[2])) {\n          return result;\n        }\n      }\n      return false;\n\n    },\n\n    // This hidden utility method extends\n    // and object's properties with a source object.\n    // Used by the p method to set properties.\n    _pObject: function(source) {\n      Q._extend(this.p,source);\n    },\n\n    _pSingle: function(property,value) {\n      this.p[property] = value;\n    },\n\n    set: function(property, value) {\n      // Is value undefined\n      if(value === void 0) {\n        this.each(this._pObject,property);\n      } else {\n        this.each(this._pSingle,property,value);\n      }\n\n      return this;\n    },\n\n    at: function(idx) {\n      return this.items[idx];\n    },\n\n    first: function() {\n      return this.items[0];\n    },\n\n    last: function() {\n      return this.items[this.items.length-1];\n    }\n\n  });\n\n  // Maybe add support for different types\n  // entity - active collision detection\n  //  particle - no collision detection, no adding components to lists / etc\n  //\n\n  // Q(\"Player\").invoke(\"shimmer); - needs to return a selector\n  // Q(\".happy\").invoke(\"sasdfa\",'fdsafas',\"fasdfas\");\n  // Q(\"Enemy\").p({ a: \"asdfasf\"  });\n\n  Q.select = function(selector,scope) {\n    scope = (scope === void 0) ? Q.activeStage : scope;\n    scope = Q.stage(scope);\n    if(Q._isNumber(selector)) {\n      return scope.index[selector];\n    } else {\n      return new Q.StageSelector(scope,selector);\n      // check if is array\n      // check is has any commas\n         // split into arrays\n      // find each of the classes\n      // find all the instances of a specific class\n    }\n  };\n\n  Q.stage = function(num) {\n    // Use activeStage is num is undefined\n    num = (num === void 0) ? Q.activeStage : num;\n    return Q.stages[num];\n  };\n\n  Q.stageScene = function(scene,num,options) {\n    // If it's a string, find a registered scene by that name\n    if(Q._isString(scene)) {\n      scene = Q.scene(scene);\n    }\n\n    // If the user skipped the num arg and went straight to options,\n    // swap the two and grab a default for num\n    if(Q._isObject(num)) {\n      options = num;\n      num = Q._popProperty(options,\"stage\") || (scene && scene.opts.stage) || 0;\n    }\n\n    // Clone the options arg to prevent modification\n    options = Q._clone(options);\n\n    // Grab the stage class, pulling from options, the scene default, or use\n    // the default stage\n    var StageClass = (Q._popProperty(options,\"stageClass\")) || \n                     (scene && scene.opts.stageClass) || Q.Stage;\n\n    // Figure out which stage to use\n    num = Q._isUndefined(num) ? ((scene && scene.opts.stage) || 0) : num;\n\n    // Clean up an existing stage if necessary\n    if(Q.stages[num]) {\n      Q.stages[num].destroy();\n    }\n\n    // Make this this the active stage and initialize the stage,\n    // calling loadScene to popuplate the stage if we have a scene.\n    Q.activeStage = num;\n    Q.stages[num] = new StageClass(scene,options);\n    if(scene) {\n      Q.stages[num].loadScene();\n    }\n    Q.activeStage = 0;\n\n    // If there's no loop active, run the default stageGameLoop\n    if(!Q.loop) {\n      Q.gameLoop(Q.stageGameLoop);\n    }\n\n    // Finally return the stage to the user for use if needed\n    return Q.stages[num];\n  };\n\n  Q.stageGameLoop = function(dt) {\n    if(Q.ctx) { Q.clear(); }\n\n    if(dt < 0) { dt = 1.0/60; }\n    if(dt > 1/15) { dt  = 1.0/15; }\n\n    for(var i =0,len=Q.stages.length;i<len;i++) {\n      Q.activeStage = i;\n      var stage = Q.stage();\n      if(stage) {\n        stage.step(dt);\n        stage.render(Q.ctx);\n      }\n    }\n\n    Q.activeStage = 0;\n\n    if(Q.input && Q.ctx) { Q.input.drawCanvas(Q.ctx); }\n  };\n\n  Q.clearStage = function(num) {\n    if(Q.stages[num]) { \n      Q.stages[num].destroy(); \n      Q.stages[num] = null;\n    }\n  };\n\n  Q.clearStages = function() {\n    for(var i=0,len=Q.stages.length;i<len;i++) {\n      if(Q.stages[i]) { Q.stages[i].destroy(); }\n    }\n    Q.stages.length = 0;\n  };\n\n\n};\n\n\n/*global Quintus:false */\n\nQuintus[\"2D\"] = function(Q) {\n\n  Q.component('viewport',{\n    added: function() {\n      this.entity.on('prerender',this,'prerender');\n      this.entity.on('render',this,'postrender');\n      this.x = 0;\n      this.y = 0;\n      this.offsetX = 0;\n      this.offsetY = 0;\n      this.centerX = Q.width/2;\n      this.centerY = Q.height/2;\n      this.scale = 1;\n    },\n\n    extend: {\n      follow: function(sprite,directions) {\n        this.off('poststep',this.viewport,'follow');\n        this.viewport.directions = directions || { x: true, y: true };\n        this.viewport.following = sprite;\n        this.on('poststep',this.viewport,'follow');\n        this.viewport.follow(true);\n      },\n\n      unfollow: function() {\n        this.off('poststep',this.viewport,'follow');\n      },\n\n      centerOn: function(x,y) {\n        this.viewport.centerOn(x,y);\n      },\n\n      moveTo: function(x,y) {\n        return this.viewport.moveTo(x,y);\n      }\n    },\n\n    follow: function(first) {\n      var followX = Q._isFunction(this.directions.x) ? this.directions.x(this.following) : this.directions.x;\n      var followY = Q._isFunction(this.directions.y) ? this.directions.y(this.following) : this.directions.y;\n\n      this[first === true ? 'centerOn' : 'softCenterOn'](\n                    followX ? \n                      this.following.p.x + this.following.p.w/2 - this.offsetX :\n                      undefined,\n                    followY ?\n                     this.following.p.y + this.following.p.h/2 - this.offsetY :\n                     undefined\n                  );\n    },\n\n    offset: function(x,y) {\n      this.offsetX = x;\n      this.offsetY = y;\n    },\n\n    softCenterOn: function(x,y) {\n      if(x !== void 0) {\n        this.x += (x - Q.width / 2 / this.scale - this.x)/3;\n      }\n      if(y !== void 0) { \n        this.y += (y - Q.height / 2 / this.scale - this.y)/3;\n      }\n\n    },\n    centerOn: function(x,y) {\n      if(x !== void 0) {\n        this.x = x - Q.width / 2 / this.scale;\n      }\n      if(y !== void 0) { \n        this.y = y - Q.height / 2 / this.scale;\n      }\n\n    },\n\n    moveTo: function(x,y) {\n      if(x !== void 0) {\n        this.x = x;\n      }\n      if(y !== void 0) { \n        this.y = y;\n      }\n      return this.entity;\n\n    },\n\n    prerender: function() {\n      this.centerX = this.x + Q.width / 2 /this.scale;\n      this.centerY = this.y + Q.height / 2 /this.scale;\n      Q.ctx.save();\n      Q.ctx.translate(Math.floor(Q.width/2),Math.floor(Q.height/2));\n      Q.ctx.scale(this.scale,this.scale);\n      Q.ctx.translate(-Math.floor(this.centerX), -Math.floor(this.centerY));\n    },\n\n    postrender: function() {\n      Q.ctx.restore();\n    }\n  });\n\n\n Q.TileLayer = Q.Sprite.extend({\n\n    init: function(props) {\n      this._super(props,{\n        tileW: 32,\n        tileH: 32,\n        blockTileW: 10,\n        blockTileH: 10,\n        type: 1\n      });\n      if(this.p.dataAsset) {\n        this.load(this.p.dataAsset);\n      }\n      this.blocks = [];\n      this.p.blockW = this.p.tileW * this.p.blockTileW;\n      this.p.blockH = this.p.tileH * this.p.blockTileH;\n      this.colBounds = {}; \n      this.directions = [ 'top','left','right','bottom'];\n\n      this.collisionObject = { \n        p: {\n          w: this.p.tileW,\n          h: this.p.tileH,\n          cx: this.p.tileW/2,\n          cy: this.p.tileH/2\n        }\n      };\n\n      this.collisionNormal = { separate: []};\n    },\n\n    load: function(dataAsset) {\n      var data = Q._isString(dataAsset) ?  Q.asset(dataAsset) : dataAsset;\n      this.p.tiles = data;\n      this.p.rows = data.length;\n      this.p.cols = data[0].length;\n      this.p.w = this.p.rows * this.p.tileH;\n      this.p.h = this.p.cols * this.p.tileW;\n    },\n\n    getTile: function(tileX,tileY) {\n      return this.p.tiles[tileY] && this.p.tiles[tileY][tileX];\n    },\n\n    setTile: function(x,y,tile) {\n      var p = this.p,\n          blockX = Math.floor(x/p.blockTileW),\n          blockY = Math.floor(y/p.blockTileH);\n\n      if(blockX >= 0 && blockY >= 0 &&\n         blockX < this.p.cols &&\n         blockY <  this.p.cols) {\n        this.p.tiles[y][x] = tile;\n        if(this.blocks[blockY]) {\n          this.blocks[blockY][blockX] = null;\n        }\n      }\n    },\n\n    tilePresent: function(tileX,tileY) {\n      return this.p.tiles[tileY] && this.collidableTile(this.p.tiles[tileY][tileX]);\n    },\n\n    // Overload this method to draw tiles at frame 0 or not draw\n    // tiles at higher number frames\n    drawableTile: function(tileNum) {\n      return tileNum > 0;\n    },\n\n    // Overload this method to control which tiles trigger a collision\n    // (defaults to all tiles > number 0)\n    collidableTile: function(tileNum) {\n      return tileNum > 0;\n    },\n\n    collide: function(obj) {\n      var p = this.p,\n          tileStartX = Math.floor((obj.p.x - obj.p.cx - p.x) / p.tileW),\n          tileStartY = Math.floor((obj.p.y - obj.p.cy - p.y) / p.tileH),\n          tileEndX =  Math.floor((obj.p.x - obj.p.cx + obj.p.w - p.x) / p.tileW),\n          tileEndY =  Math.floor((obj.p.y - obj.p.cy + obj.p.h - p.y) / p.tileH),\n          colObj = this.collisionObject,\n          normal = this.collisionNormal,\n          col;\n  \n      normal.collided = false;\n\n      for(var tileY = tileStartY; tileY<=tileEndY; tileY++) {\n        for(var tileX = tileStartX; tileX<=tileEndX; tileX++) {\n          if(this.tilePresent(tileX,tileY)) {\n            colObj.p.x = tileX * p.tileW + p.x + p.tileW/2;\n            colObj.p.y = tileY * p.tileH + p.y + p.tileH/2;\n            \n            col = Q.collision(obj,colObj);\n            if(col && col.magnitude > 0 && \n               (!normal.collided || normal.magnitude < col.magnitude )) {\n                 normal.collided = true;\n                 normal.separate[0] = col.separate[0];\n                 normal.separate[1] = col.separate[1];\n                 normal.magnitude = col.magnitude;\n                 normal.distance = col.distance;\n                 normal.normalX = col.normalX;\n                 normal.normalY = col.normalY;\n                 normal.tileX = tileX;\n                 normal.tileY = tileY;\n                 normal.tile = this.getTile(tileX,tileY);\n            }\n          }\n        }\n      }\n\n      return normal.collided ? normal : false;\n    },\n\n    prerenderBlock: function(blockX,blockY) {\n      var p = this.p,\n          tiles = p.tiles,\n          sheet = this.sheet(),\n          blockOffsetX = blockX*p.blockTileW,\n          blockOffsetY = blockY*p.blockTileH;\n\n      if(blockOffsetX < 0 || blockOffsetX >= this.p.cols ||\n         blockOffsetY < 0 || blockOffsetY >= this.p.rows) {\n           return;\n      }\n\n      var canvas = document.createElement('canvas'),\n          ctx = canvas.getContext('2d');\n\n      canvas.width = p.blockW;\n      canvas.height= p.blockH;\n      this.blocks[blockY] = this.blocks[blockY] || {};\n      this.blocks[blockY][blockX] = canvas;\n\n      for(var y=0;y<p.blockTileH;y++) {\n        if(tiles[y+blockOffsetY]) {\n          for(var x=0;x<p.blockTileW;x++) {\n            if(this.drawableTile(tiles[y+blockOffsetY][x+blockOffsetX])) {\n              sheet.draw(ctx,\n                         x*p.tileW,\n                         y*p.tileH,\n                         tiles[y+blockOffsetY][x+blockOffsetX]);\n            }\n          }\n        }\n      }\n    },\n\n    drawBlock: function(ctx, blockX, blockY) {\n      var p = this.p,\n          startX = Math.floor(blockX * p.blockW + p.x),\n          startY = Math.floor(blockY * p.blockH + p.y);\n\n      if(!this.blocks[blockY] || !this.blocks[blockY][blockX]) {\n        this.prerenderBlock(blockX,blockY);\n      }\n\n      if(this.blocks[blockY]  && this.blocks[blockY][blockX]) {\n        ctx.drawImage(this.blocks[blockY][blockX],startX,startY);\n      }\n    },\n\n    draw: function(ctx) {\n      var p = this.p,\n          viewport = this.stage.viewport,\n          scale = viewport ? viewport.scale : 1,\n          x = viewport ? viewport.x : 0,\n          y = viewport ? viewport.y : 0,\n          viewW = Q.width / scale,\n          viewH = Q.height / scale,\n          startBlockX = Math.floor((x - p.x) / p.blockW),\n          startBlockY = Math.floor((y - p.y) / p.blockH),\n          endBlockX = Math.floor((x + viewW - p.x) / p.blockW),\n          endBlockY = Math.floor((y + viewH - p.y) / p.blockH);\n\n      for(var iy=startBlockY;iy<=endBlockY;iy++) {\n        for(var ix=startBlockX;ix<=endBlockX;ix++) {\n          this.drawBlock(ctx,ix,iy);\n        }\n      }\n    }\n  });\n\n  Q.gravityY = 9.8*100;\n  Q.gravityX = 0;\n  Q.dx = 0.05;\n\n  Q.component('2d',{\n    added: function() {\n      var entity = this.entity;\n      Q._defaults(entity.p,{\n        vx: 0,\n        vy: 0,\n        ax: 0,\n        ay: 0,\n        gravity: 1,\n        collisionMask: Q.SPRITE_DEFAULT\n      });\n      entity.on('step',this,\"step\");\n      entity.on('hit',this,'collision');\n    },\n\n    collision: function(col,last) {\n      var entity = this.entity,\n          p = entity.p,\n          magnitude = 0;\n\n      col.impact = 0;\n      var impactX = Math.abs(p.vx);\n      var impactY = Math.abs(p.vy);\n\n      p.x -= col.separate[0];\n      p.y -= col.separate[1];\n\n      // Top collision\n      if(col.normalY < -0.3) { \n        if(p.vy > 0) { p.vy = 0; }\n        col.impact = impactY;\n        entity.trigger(\"bump.bottom\",col);\n      }\n      if(col.normalY > 0.3) {\n        if(p.vy < 0) { p.vy = 0; }\n        col.impact = impactY;\n\n        entity.trigger(\"bump.top\",col);\n      }\n\n      if(col.normalX < -0.3) { \n        if(p.vx > 0) { p.vx = 0;  }\n        col.impact = impactX;\n        entity.trigger(\"bump.right\",col);\n      }\n      if(col.normalX > 0.3) { \n        if(p.vx < 0) { p.vx = 0; }\n        col.impact = impactX;\n\n        entity.trigger(\"bump.left\",col);\n      }\n\n\n    },\n\n    step: function(dt) {\n      var p = this.entity.p,\n          dtStep = dt;\n      // TODO: check the entity's magnitude of vx and vy,\n      // reduce the max dtStep if necessary to prevent \n      // skipping through objects.\n      while(dtStep > 0) {\n        dt = Math.min(1/30,dtStep);\n        // Updated based on the velocity and acceleration\n        p.vx += p.ax * dt + Q.gravityX * dt * p.gravity;\n        p.vy += p.ay * dt + Q.gravityY * dt * p.gravity;\n        p.x += p.vx * dt;\n        p.y += p.vy * dt;\n\n        this.entity.stage.collide(this.entity);\n        dtStep -= dt;\n      }\n    }\n  });\n\n  Q.component('aiBounce', {\n    added: function() {\n      this.entity.on(\"bump.right\",this,\"goLeft\");\n      this.entity.on(\"bump.left\",this,\"goRight\");\n    },\n\n    goLeft: function(col) {\n      this.entity.p.vx = -col.impact;\n    },\n\n    goRight: function(col) {\n      this.entity.p.vx = col.impact;\n    }\n  });\n\n};\n"]],"start1":0,"start2":0,"length1":0,"length2":134920}]],"length":134920,"saved":false}
